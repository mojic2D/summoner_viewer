define(['dart_sdk', 'packages/flutter/src/painting/basic_types.dart', 'packages/flutter/src/rendering/sliver.dart', 'packages/flutter/src/foundation/debug.dart', 'packages/flutter/src/rendering/layer.dart', 'packages/flutter/src/animation/curves.dart', 'packages/flutter/src/scheduler/ticker.dart', 'packages/flutter/src/rendering/viewport_offset.dart', 'packages/flutter/src/animation/animation_controller.dart', 'packages/flutter/src/animation/listener_helpers.dart'], (function load__packages__flutter__src__rendering__sliver_persistent_header_dart(dart_sdk, packages__flutter__src__painting__basic_types$46dart, packages__flutter__src__rendering__sliver$46dart, packages__flutter__src__foundation__debug$46dart, packages__flutter__src__rendering__layer$46dart, packages__flutter__src__animation__curves$46dart, packages__flutter__src__scheduler__ticker$46dart, packages__flutter__src__rendering__viewport_offset$46dart, packages__flutter__src__animation__animation_controller$46dart, packages__flutter__src__animation__listener_helpers$46dart) {
  'use strict';
  const core = dart_sdk.core;
  const async = dart_sdk.async;
  const math = dart_sdk.math;
  const _interceptors = dart_sdk._interceptors;
  const ui = dart_sdk.ui;
  const dart = dart_sdk.dart;
  const dartx = dart_sdk.dartx;
  const basic_types = packages__flutter__src__painting__basic_types$46dart.src__painting__basic_types;
  const sliver = packages__flutter__src__rendering__sliver$46dart.src__rendering__sliver;
  const viewport = packages__flutter__src__rendering__sliver$46dart.src__rendering__viewport;
  const assertions = packages__flutter__src__foundation__debug$46dart.src__foundation__assertions;
  const diagnostics = packages__flutter__src__foundation__debug$46dart.src__foundation__diagnostics;
  const object = packages__flutter__src__rendering__layer$46dart.src__rendering__object;
  const box = packages__flutter__src__rendering__layer$46dart.src__rendering__box;
  const curves = packages__flutter__src__animation__curves$46dart.src__animation__curves;
  const ticker = packages__flutter__src__scheduler__ticker$46dart.src__scheduler__ticker;
  const viewport_offset = packages__flutter__src__rendering__viewport_offset$46dart.src__rendering__viewport_offset;
  const animation_controller = packages__flutter__src__animation__animation_controller$46dart.src__animation__animation_controller;
  const tween = packages__flutter__src__animation__listener_helpers$46dart.src__animation__tween;
  const animation = packages__flutter__src__animation__listener_helpers$46dart.src__animation__animation;
  var sliver_persistent_header = Object.create(dart.library);
  var $abs = dartx.abs;
  var $clamp = dartx.clamp;
  var doubleL = () => (doubleL = dart.constFn(dart.legacy(core.double)))();
  var SliverConstraintsL = () => (SliverConstraintsL = dart.constFn(dart.legacy(sliver.SliverConstraints)))();
  var SliverConstraintsLToNullN = () => (SliverConstraintsLToNullN = dart.constFn(dart.fnType(core.Null, [SliverConstraintsL()])))();
  var DiagnosticsNodeL = () => (DiagnosticsNodeL = dart.constFn(dart.legacy(diagnostics.DiagnosticsNode)))();
  var JSArrayOfDiagnosticsNodeL = () => (JSArrayOfDiagnosticsNodeL = dart.constFn(_interceptors.JSArray$(DiagnosticsNodeL())))();
  var boolL = () => (boolL = dart.constFn(dart.legacy(core.bool)))();
  var VoidToboolL = () => (VoidToboolL = dart.constFn(dart.fnType(boolL(), [])))();
  var RenderObjectL = () => (RenderObjectL = dart.constFn(dart.legacy(object.RenderObject)))();
  var RenderBoxL = () => (RenderBoxL = dart.constFn(dart.legacy(box.RenderBox)))();
  var VoidTodoubleL = () => (VoidTodoubleL = dart.constFn(dart.fnType(doubleL(), [])))();
  var VoidToNullN = () => (VoidToNullN = dart.constFn(dart.fnType(core.Null, [])))();
  var TweenOfdoubleL = () => (TweenOfdoubleL = dart.constFn(tween.Tween$(doubleL())))();
  const CT = Object.create(null);
  var L0 = "file:///C:/flutter/packages/flutter/lib/src/rendering/sliver_persistent_header.dart";
  var L1 = "package:flutter/src/rendering/sliver_persistent_header.dart";
  dart.defineLazy(CT, {
    get C0() {
      return C0 = dart.const({
        __proto__: basic_types.Axis.prototype,
        [_name]: "Axis.vertical",
        index: 1
      });
    },
    get C1() {
      return C1 = dart.const({
        __proto__: basic_types.Axis.prototype,
        [_name]: "Axis.horizontal",
        index: 0
      });
    },
    get C2() {
      return C2 = dart.const({
        __proto__: basic_types.AxisDirection.prototype,
        [_name]: "AxisDirection.up",
        index: 0
      });
    },
    get C3() {
      return C3 = dart.const({
        __proto__: basic_types.AxisDirection.prototype,
        [_name]: "AxisDirection.down",
        index: 2
      });
    },
    get C4() {
      return C4 = dart.const({
        __proto__: basic_types.AxisDirection.prototype,
        [_name]: "AxisDirection.left",
        index: 3
      });
    },
    get C5() {
      return C5 = dart.const({
        __proto__: basic_types.AxisDirection.prototype,
        [_name]: "AxisDirection.right",
        index: 1
      });
    },
    get C6() {
      return C6 = dart.const({
        __proto__: curves.Cubic.prototype,
        [Cubic_d]: 1,
        [Cubic_c]: 0.25,
        [Cubic_b]: 0.1,
        [Cubic_a]: 0.25
      });
    },
    get C7() {
      return C7 = dart.const({
        __proto__: core.Duration.prototype,
        [Duration__duration]: 300000
      });
    }
  }, false);
  var stretchTriggerOffset$ = dart.privateName(sliver_persistent_header, "OverScrollHeaderStretchConfiguration.stretchTriggerOffset");
  var onStretchTrigger$ = dart.privateName(sliver_persistent_header, "OverScrollHeaderStretchConfiguration.onStretchTrigger");
  sliver_persistent_header.OverScrollHeaderStretchConfiguration = class OverScrollHeaderStretchConfiguration extends core.Object {
    get stretchTriggerOffset() {
      return this[stretchTriggerOffset$];
    }
    set stretchTriggerOffset(value) {
      super.stretchTriggerOffset = value;
    }
    get onStretchTrigger() {
      return this[onStretchTrigger$];
    }
    set onStretchTrigger(value) {
      super.onStretchTrigger = value;
    }
  };
  (sliver_persistent_header.OverScrollHeaderStretchConfiguration.new = function(opts) {
    let stretchTriggerOffset = opts && 'stretchTriggerOffset' in opts ? opts.stretchTriggerOffset : 100;
    let onStretchTrigger = opts && 'onStretchTrigger' in opts ? opts.onStretchTrigger : null;
    this[stretchTriggerOffset$] = stretchTriggerOffset;
    this[onStretchTrigger$] = onStretchTrigger;
    if (!(stretchTriggerOffset != null)) dart.assertFailed(null, L0, 34, 15, "stretchTriggerOffset != null");
    ;
  }).prototype = sliver_persistent_header.OverScrollHeaderStretchConfiguration.prototype;
  dart.addTypeTests(sliver_persistent_header.OverScrollHeaderStretchConfiguration);
  dart.addTypeCaches(sliver_persistent_header.OverScrollHeaderStretchConfiguration);
  dart.setLibraryUri(sliver_persistent_header.OverScrollHeaderStretchConfiguration, L1);
  dart.setFieldSignature(sliver_persistent_header.OverScrollHeaderStretchConfiguration, () => ({
    __proto__: dart.getFields(sliver_persistent_header.OverScrollHeaderStretchConfiguration.__proto__),
    stretchTriggerOffset: dart.finalFieldType(dart.legacy(core.double)),
    onStretchTrigger: dart.finalFieldType(dart.legacy(dart.fnType(async.Future$(dart.void), [])))
  }));
  var _lastStretchOffset = dart.privateName(sliver_persistent_header, "_lastStretchOffset");
  var _needsUpdateChild = dart.privateName(sliver_persistent_header, "_needsUpdateChild");
  var _lastShrinkOffset = dart.privateName(sliver_persistent_header, "_lastShrinkOffset");
  var _lastOverlapsContent = dart.privateName(sliver_persistent_header, "_lastOverlapsContent");
  var _name = dart.privateName(basic_types, "_name");
  var C0;
  var C1;
  var C2;
  var C3;
  var C4;
  var C5;
  var stretchConfiguration$ = dart.privateName(sliver_persistent_header, "RenderSliverPersistentHeader.stretchConfiguration");
  const RenderSliver_RenderObjectWithChildMixin$36 = class RenderSliver_RenderObjectWithChildMixin extends sliver.RenderSliver {};
  (RenderSliver_RenderObjectWithChildMixin$36.new = function() {
    object.RenderObjectWithChildMixin$(dart.legacy(box.RenderBox))[dart.mixinNew].call(this);
    RenderSliver_RenderObjectWithChildMixin$36.__proto__.new.call(this);
  }).prototype = RenderSliver_RenderObjectWithChildMixin$36.prototype;
  dart.applyMixin(RenderSliver_RenderObjectWithChildMixin$36, object.RenderObjectWithChildMixin$(dart.legacy(box.RenderBox)));
  const RenderSliver_RenderSliverHelpers$36 = class RenderSliver_RenderSliverHelpers extends RenderSliver_RenderObjectWithChildMixin$36 {};
  (RenderSliver_RenderSliverHelpers$36.new = function() {
    RenderSliver_RenderSliverHelpers$36.__proto__.new.call(this);
  }).prototype = RenderSliver_RenderSliverHelpers$36.prototype;
  dart.applyMixin(RenderSliver_RenderSliverHelpers$36, sliver.RenderSliverHelpers);
  sliver_persistent_header.RenderSliverPersistentHeader = class RenderSliverPersistentHeader extends RenderSliver_RenderSliverHelpers$36 {
    get stretchConfiguration() {
      return this[stretchConfiguration$];
    }
    set stretchConfiguration(value) {
      this[stretchConfiguration$] = value;
    }
    get childExtent() {
      if (this.child == null) return 0.0;
      if (!dart.test(this.child.hasSize)) dart.assertFailed(null, L0, 93, 12, "child.hasSize");
      if (!(this.constraints.axis != null)) dart.assertFailed(null, L0, 94, 12, "constraints.axis != null");
      switch (this.constraints.axis) {
        case C0 || CT.C0:
        {
          return this.child.size.height;
        }
        case C1 || CT.C1:
        {
          return this.child.size.width;
        }
      }
      return null;
    }
    updateChild(shrinkOffset, overlapsContent) {
    }
    markNeedsLayout() {
      this[_needsUpdateChild] = true;
      super.markNeedsLayout();
    }
    layoutChild(scrollOffset, maxExtent, opts) {
      let t0;
      let overlapsContent = opts && 'overlapsContent' in opts ? opts.overlapsContent : false;
      if (!(maxExtent != null)) dart.assertFailed(null, L0, 160, 12, "maxExtent != null");
      let shrinkOffset = math.min(doubleL(), scrollOffset, maxExtent);
      if (dart.test(this[_needsUpdateChild]) || this[_lastShrinkOffset] !== shrinkOffset || !dart.equals(this[_lastOverlapsContent], overlapsContent)) {
        this.invokeLayoutCallback(SliverConstraintsL(), dart.fn(constraints => {
          if (!dart.equals(constraints, this.constraints)) dart.assertFailed(null, L0, 164, 16, "constraints == this.constraints");
          this.updateChild(shrinkOffset, overlapsContent);
        }, SliverConstraintsLToNullN()));
        this[_lastShrinkOffset] = shrinkOffset;
        this[_lastOverlapsContent] = overlapsContent;
        this[_needsUpdateChild] = false;
      }
      if (!(this.minExtent != null)) dart.assertFailed(null, L0, 171, 12, "minExtent != null");
      if (!dart.test(dart.fn(() => {
        if (dart.notNull(this.minExtent) <= dart.notNull(maxExtent)) return true;
        dart.throw(new assertions.FlutterError.fromParts(JSArrayOfDiagnosticsNodeL().of([new assertions.ErrorSummary.new("The maxExtent for this " + dart.str(this.runtimeType) + " is less than its minExtent."), new diagnostics.DoubleProperty.new("The specified maxExtent was", maxExtent), new diagnostics.DoubleProperty.new("The specified minExtent was", this.minExtent)])));
      }, VoidToboolL())())) dart.assertFailed(null, L0, 172, 12, "() {\r\n      if (minExtent <= maxExtent)\r\n        return true;\r\n      throw FlutterError.fromParts(<DiagnosticsNode>[\r\n        ErrorSummary('The maxExtent for this $runtimeType is less than its minExtent.'),\r\n        DoubleProperty('The specified maxExtent was', maxExtent),\r\n        DoubleProperty('The specified minExtent was', minExtent),\r\n      ]);\r\n    }()");
      let stretchOffset = 0.0;
      if (this.stretchConfiguration != null && this.childMainAxisPosition(this.child) === 0.0) stretchOffset = stretchOffset + this.constraints.overlap[$abs]();
      t0 = this.child;
      t0 == null ? null : t0.layout(this.constraints.asBoxConstraints({maxExtent: math.max(doubleL(), this.minExtent, dart.notNull(maxExtent) - shrinkOffset) + stretchOffset}), {parentUsesSize: true});
      if (this.stretchConfiguration != null && this.stretchConfiguration.onStretchTrigger != null && stretchOffset >= dart.notNull(this.stretchConfiguration.stretchTriggerOffset) && dart.notNull(this[_lastStretchOffset]) <= dart.notNull(this.stretchConfiguration.stretchTriggerOffset)) {
        this.stretchConfiguration.onStretchTrigger();
      }
      this[_lastStretchOffset] = stretchOffset;
    }
    childMainAxisPosition(child) {
      RenderObjectL().as(child);
      return super.childMainAxisPosition(child);
    }
    hitTestChildren(result, opts) {
      let mainAxisPosition = opts && 'mainAxisPosition' in opts ? opts.mainAxisPosition : null;
      let crossAxisPosition = opts && 'crossAxisPosition' in opts ? opts.crossAxisPosition : null;
      if (!(dart.notNull(this.geometry.hitTestExtent) > 0.0)) dart.assertFailed(null, L0, 226, 12, "geometry.hitTestExtent > 0.0");
      if (this.child != null) return this.hitTestBoxChild(new box.BoxHitTestResult.wrap(result), this.child, {mainAxisPosition: mainAxisPosition, crossAxisPosition: crossAxisPosition});
      return false;
    }
    applyPaintTransform(child, transform) {
      RenderObjectL().as(child);
      if (!(child != null)) dart.assertFailed(null, L0, 234, 12, "child != null");
      if (!dart.equals(child, this.child)) dart.assertFailed(null, L0, 235, 12, "child == this.child");
      this.applyPaintTransformForBoxChild(RenderBoxL().as(child), transform);
    }
    paint(context, offset) {
      if (this.child != null && dart.test(this.geometry.visible)) {
        if (!(this.constraints.axisDirection != null)) dart.assertFailed(null, L0, 242, 14, "constraints.axisDirection != null");
        switch (sliver.applyGrowthDirectionToAxisDirection(this.constraints.axisDirection, this.constraints.growthDirection)) {
          case C2 || CT.C2:
          {
            offset = offset['+'](new ui.Offset.new(0.0, dart.notNull(this.geometry.paintExtent) - dart.notNull(this.childMainAxisPosition(this.child)) - dart.notNull(this.childExtent)));
            break;
          }
          case C3 || CT.C3:
          {
            offset = offset['+'](new ui.Offset.new(0.0, this.childMainAxisPosition(this.child)));
            break;
          }
          case C4 || CT.C4:
          {
            offset = offset['+'](new ui.Offset.new(dart.notNull(this.geometry.paintExtent) - dart.notNull(this.childMainAxisPosition(this.child)) - dart.notNull(this.childExtent), 0.0));
            break;
          }
          case C5 || CT.C5:
          {
            offset = offset['+'](new ui.Offset.new(this.childMainAxisPosition(this.child), 0.0));
            break;
          }
        }
        context.paintChild(this.child, offset);
      }
    }
    describeSemanticsConfiguration(config) {
      super.describeSemanticsConfiguration(config);
      config.addTagForChildren(viewport.RenderViewport.excludeFromScrolling);
    }
    debugFillProperties(properties) {
      super.debugFillProperties(properties);
      properties.add(new diagnostics.DoubleProperty.lazy("maxExtent", dart.fn(() => this.maxExtent, VoidTodoubleL())));
      properties.add(new diagnostics.DoubleProperty.lazy("child position", dart.fn(() => this.childMainAxisPosition(this.child), VoidTodoubleL())));
    }
  };
  (sliver_persistent_header.RenderSliverPersistentHeader.new = function(opts) {
    let child = opts && 'child' in opts ? opts.child : null;
    let stretchConfiguration = opts && 'stretchConfiguration' in opts ? opts.stretchConfiguration : null;
    this[_lastStretchOffset] = null;
    this[_needsUpdateChild] = true;
    this[_lastShrinkOffset] = 0.0;
    this[_lastOverlapsContent] = false;
    this[stretchConfiguration$] = stretchConfiguration;
    sliver_persistent_header.RenderSliverPersistentHeader.__proto__.new.call(this);
    this.child = child;
  }).prototype = sliver_persistent_header.RenderSliverPersistentHeader.prototype;
  dart.addTypeTests(sliver_persistent_header.RenderSliverPersistentHeader);
  dart.addTypeCaches(sliver_persistent_header.RenderSliverPersistentHeader);
  dart.setMethodSignature(sliver_persistent_header.RenderSliverPersistentHeader, () => ({
    __proto__: dart.getMethods(sliver_persistent_header.RenderSliverPersistentHeader.__proto__),
    updateChild: dart.fnType(dart.void, [dart.legacy(core.double), dart.legacy(core.bool)]),
    layoutChild: dart.fnType(dart.void, [dart.legacy(core.double), dart.legacy(core.double)], {overlapsContent: dart.legacy(core.bool)}, {})
  }));
  dart.setGetterSignature(sliver_persistent_header.RenderSliverPersistentHeader, () => ({
    __proto__: dart.getGetters(sliver_persistent_header.RenderSliverPersistentHeader.__proto__),
    childExtent: dart.legacy(core.double)
  }));
  dart.setLibraryUri(sliver_persistent_header.RenderSliverPersistentHeader, L1);
  dart.setFieldSignature(sliver_persistent_header.RenderSliverPersistentHeader, () => ({
    __proto__: dart.getFields(sliver_persistent_header.RenderSliverPersistentHeader.__proto__),
    [_lastStretchOffset]: dart.fieldType(dart.legacy(core.double)),
    [_needsUpdateChild]: dart.fieldType(dart.legacy(core.bool)),
    [_lastShrinkOffset]: dart.fieldType(dart.legacy(core.double)),
    [_lastOverlapsContent]: dart.fieldType(dart.legacy(core.bool)),
    stretchConfiguration: dart.fieldType(dart.legacy(sliver_persistent_header.OverScrollHeaderStretchConfiguration))
  }));
  var _childPosition = dart.privateName(sliver_persistent_header, "_childPosition");
  sliver_persistent_header.RenderSliverScrollingPersistentHeader = class RenderSliverScrollingPersistentHeader extends sliver_persistent_header.RenderSliverPersistentHeader {
    updateGeometry() {
      let stretchOffset = 0.0;
      if (this.stretchConfiguration != null && this[_childPosition] === 0.0) {
        stretchOffset = stretchOffset + this.constraints.overlap[$abs]();
      }
      let maxExtent = this.maxExtent;
      let paintExtent = dart.notNull(maxExtent) - dart.notNull(this.constraints.scrollOffset);
      this.geometry = new sliver.SliverGeometry.new({scrollExtent: maxExtent, paintOrigin: math.min(doubleL(), this.constraints.overlap, 0.0), paintExtent: paintExtent[$clamp](0.0, this.constraints.remainingPaintExtent), maxPaintExtent: dart.notNull(maxExtent) + stretchOffset, hasVisualOverflow: true});
      return stretchOffset > 0 ? 0.0 : math.min(doubleL(), 0.0, paintExtent - dart.notNull(this.childExtent));
    }
    performLayout() {
      let constraints = this.constraints;
      let maxExtent = this.maxExtent;
      this.layoutChild(constraints.scrollOffset, maxExtent);
      let paintExtent = dart.notNull(maxExtent) - dart.notNull(constraints.scrollOffset);
      this.geometry = new sliver.SliverGeometry.new({scrollExtent: maxExtent, paintOrigin: math.min(doubleL(), constraints.overlap, 0.0), paintExtent: paintExtent[$clamp](0.0, constraints.remainingPaintExtent), maxPaintExtent: maxExtent, hasVisualOverflow: true});
      this[_childPosition] = this.updateGeometry();
    }
    childMainAxisPosition(child) {
      RenderBoxL().as(child);
      if (!dart.equals(child, this.child)) dart.assertFailed(null, L0, 335, 12, "child == this.child");
      return this[_childPosition];
    }
  };
  (sliver_persistent_header.RenderSliverScrollingPersistentHeader.new = function(opts) {
    let child = opts && 'child' in opts ? opts.child : null;
    let stretchConfiguration = opts && 'stretchConfiguration' in opts ? opts.stretchConfiguration : null;
    this[_childPosition] = null;
    sliver_persistent_header.RenderSliverScrollingPersistentHeader.__proto__.new.call(this, {child: child, stretchConfiguration: stretchConfiguration});
    ;
  }).prototype = sliver_persistent_header.RenderSliverScrollingPersistentHeader.prototype;
  dart.addTypeTests(sliver_persistent_header.RenderSliverScrollingPersistentHeader);
  dart.addTypeCaches(sliver_persistent_header.RenderSliverScrollingPersistentHeader);
  dart.setMethodSignature(sliver_persistent_header.RenderSliverScrollingPersistentHeader, () => ({
    __proto__: dart.getMethods(sliver_persistent_header.RenderSliverScrollingPersistentHeader.__proto__),
    updateGeometry: dart.fnType(dart.legacy(core.double), []),
    performLayout: dart.fnType(dart.void, [])
  }));
  dart.setLibraryUri(sliver_persistent_header.RenderSliverScrollingPersistentHeader, L1);
  dart.setFieldSignature(sliver_persistent_header.RenderSliverScrollingPersistentHeader, () => ({
    __proto__: dart.getFields(sliver_persistent_header.RenderSliverScrollingPersistentHeader.__proto__),
    [_childPosition]: dart.fieldType(dart.legacy(core.double))
  }));
  sliver_persistent_header.RenderSliverPinnedPersistentHeader = class RenderSliverPinnedPersistentHeader extends sliver_persistent_header.RenderSliverPersistentHeader {
    performLayout() {
      let constraints = this.constraints;
      let maxExtent = this.maxExtent;
      let overlapsContent = dart.notNull(constraints.overlap) > 0.0;
      this.layoutChild(constraints.scrollOffset, maxExtent, {overlapsContent: overlapsContent});
      let effectiveRemainingPaintExtent = math.max(doubleL(), 0.0, dart.notNull(constraints.remainingPaintExtent) - dart.notNull(constraints.overlap));
      let layoutExtent = (dart.notNull(maxExtent) - dart.notNull(constraints.scrollOffset))[$clamp](0.0, effectiveRemainingPaintExtent);
      let stretchOffset = this.stretchConfiguration != null ? constraints.overlap[$abs]() : 0.0;
      this.geometry = new sliver.SliverGeometry.new({scrollExtent: maxExtent, paintOrigin: constraints.overlap, paintExtent: math.min(doubleL(), this.childExtent, effectiveRemainingPaintExtent), layoutExtent: layoutExtent, maxPaintExtent: dart.notNull(maxExtent) + stretchOffset, maxScrollObstructionExtent: this.minExtent, cacheExtent: layoutExtent > 0.0 ? -dart.notNull(constraints.cacheOrigin) + layoutExtent : layoutExtent, hasVisualOverflow: true});
    }
    childMainAxisPosition(child) {
      RenderBoxL().as(child);
      return 0.0;
    }
  };
  (sliver_persistent_header.RenderSliverPinnedPersistentHeader.new = function(opts) {
    let child = opts && 'child' in opts ? opts.child : null;
    let stretchConfiguration = opts && 'stretchConfiguration' in opts ? opts.stretchConfiguration : null;
    sliver_persistent_header.RenderSliverPinnedPersistentHeader.__proto__.new.call(this, {child: child, stretchConfiguration: stretchConfiguration});
    ;
  }).prototype = sliver_persistent_header.RenderSliverPinnedPersistentHeader.prototype;
  dart.addTypeTests(sliver_persistent_header.RenderSliverPinnedPersistentHeader);
  dart.addTypeCaches(sliver_persistent_header.RenderSliverPinnedPersistentHeader);
  dart.setMethodSignature(sliver_persistent_header.RenderSliverPinnedPersistentHeader, () => ({
    __proto__: dart.getMethods(sliver_persistent_header.RenderSliverPinnedPersistentHeader.__proto__),
    performLayout: dart.fnType(dart.void, [])
  }));
  dart.setLibraryUri(sliver_persistent_header.RenderSliverPinnedPersistentHeader, L1);
  var Cubic_d = dart.privateName(curves, "Cubic.d");
  var Cubic_c = dart.privateName(curves, "Cubic.c");
  var Cubic_b = dart.privateName(curves, "Cubic.b");
  var Cubic_a = dart.privateName(curves, "Cubic.a");
  var C6;
  var Duration__duration = dart.privateName(core, "Duration._duration");
  var C7;
  var vsync$ = dart.privateName(sliver_persistent_header, "FloatingHeaderSnapConfiguration.vsync");
  var curve$ = dart.privateName(sliver_persistent_header, "FloatingHeaderSnapConfiguration.curve");
  var duration$ = dart.privateName(sliver_persistent_header, "FloatingHeaderSnapConfiguration.duration");
  sliver_persistent_header.FloatingHeaderSnapConfiguration = class FloatingHeaderSnapConfiguration extends core.Object {
    get vsync() {
      return this[vsync$];
    }
    set vsync(value) {
      super.vsync = value;
    }
    get curve() {
      return this[curve$];
    }
    set curve(value) {
      super.curve = value;
    }
    get duration() {
      return this[duration$];
    }
    set duration(value) {
      super.duration = value;
    }
  };
  (sliver_persistent_header.FloatingHeaderSnapConfiguration.new = function(opts) {
    let vsync = opts && 'vsync' in opts ? opts.vsync : null;
    let curve = opts && 'curve' in opts ? opts.curve : C6 || CT.C6;
    let duration = opts && 'duration' in opts ? opts.duration : C7 || CT.C7;
    this[vsync$] = vsync;
    this[curve$] = curve;
    this[duration$] = duration;
    if (!(vsync != null)) dart.assertFailed(null, L0, 400, 15, "vsync != null");
    if (!(curve != null)) dart.assertFailed(null, L0, 401, 15, "curve != null");
    if (!(duration != null)) dart.assertFailed(null, L0, 402, 15, "duration != null");
    ;
  }).prototype = sliver_persistent_header.FloatingHeaderSnapConfiguration.prototype;
  dart.addTypeTests(sliver_persistent_header.FloatingHeaderSnapConfiguration);
  dart.addTypeCaches(sliver_persistent_header.FloatingHeaderSnapConfiguration);
  dart.setLibraryUri(sliver_persistent_header.FloatingHeaderSnapConfiguration, L1);
  dart.setFieldSignature(sliver_persistent_header.FloatingHeaderSnapConfiguration, () => ({
    __proto__: dart.getFields(sliver_persistent_header.FloatingHeaderSnapConfiguration.__proto__),
    vsync: dart.finalFieldType(dart.legacy(ticker.TickerProvider)),
    curve: dart.finalFieldType(dart.legacy(curves.Curve)),
    duration: dart.finalFieldType(dart.legacy(core.Duration))
  }));
  var _controller = dart.privateName(sliver_persistent_header, "_controller");
  var _animation = dart.privateName(sliver_persistent_header, "_animation");
  var _lastActualScrollOffset = dart.privateName(sliver_persistent_header, "_lastActualScrollOffset");
  var _effectiveScrollOffset = dart.privateName(sliver_persistent_header, "_effectiveScrollOffset");
  var _snapConfiguration = dart.privateName(sliver_persistent_header, "_snapConfiguration");
  sliver_persistent_header.RenderSliverFloatingPersistentHeader = class RenderSliverFloatingPersistentHeader extends sliver_persistent_header.RenderSliverPersistentHeader {
    detach() {
      let t0;
      t0 = this[_controller];
      t0 == null ? null : t0.dispose();
      this[_controller] = null;
      super.detach();
    }
    get snapConfiguration() {
      return this[_snapConfiguration];
    }
    set snapConfiguration(value) {
      let t0, t0$;
      if (dart.equals(value, this[_snapConfiguration])) return;
      if (value == null) {
        t0 = this[_controller];
        t0 == null ? null : t0.dispose();
        this[_controller] = null;
      } else {
        if (this[_snapConfiguration] != null && !dart.equals(value.vsync, this[_snapConfiguration].vsync)) {
          t0$ = this[_controller];
          t0$ == null ? null : t0$.resync(value.vsync);
        }
      }
      this[_snapConfiguration] = value;
    }
    updateGeometry() {
      let stretchOffset = 0.0;
      if (this.stretchConfiguration != null && this[_childPosition] === 0.0) {
        stretchOffset = stretchOffset + this.constraints.overlap[$abs]();
      }
      let maxExtent = this.maxExtent;
      let paintExtent = dart.notNull(maxExtent) - dart.notNull(this[_effectiveScrollOffset]);
      let layoutExtent = dart.notNull(maxExtent) - dart.notNull(this.constraints.scrollOffset);
      this.geometry = new sliver.SliverGeometry.new({scrollExtent: maxExtent, paintOrigin: math.min(doubleL(), this.constraints.overlap, 0.0), paintExtent: paintExtent[$clamp](0.0, this.constraints.remainingPaintExtent), layoutExtent: layoutExtent[$clamp](0.0, this.constraints.remainingPaintExtent), maxPaintExtent: dart.notNull(maxExtent) + stretchOffset, hasVisualOverflow: true});
      return stretchOffset > 0 ? 0.0 : math.min(doubleL(), 0.0, paintExtent - dart.notNull(this.childExtent));
    }
    maybeStartSnapAnimation(direction) {
      let t0;
      if (this.snapConfiguration == null) return;
      if (direction == viewport_offset.ScrollDirection.forward && dart.notNull(this[_effectiveScrollOffset]) <= 0.0) return;
      if (direction == viewport_offset.ScrollDirection.reverse && dart.notNull(this[_effectiveScrollOffset]) >= dart.notNull(this.maxExtent)) return;
      let vsync = this.snapConfiguration.vsync;
      let duration = this.snapConfiguration.duration;
      this[_controller] == null ? this[_controller] = (t0 = new animation_controller.AnimationController.new({vsync: vsync, duration: duration}), (() => {
        t0.addListener(dart.fn(() => {
          if (this[_effectiveScrollOffset] == this[_animation].value) return;
          this[_effectiveScrollOffset] = this[_animation].value;
          this.markNeedsLayout();
        }, VoidToNullN()));
        return t0;
      })()) : null;
      this[_animation] = this[_controller].drive(doubleL(), new (TweenOfdoubleL()).new({begin: this[_effectiveScrollOffset], end: direction == viewport_offset.ScrollDirection.forward ? 0.0 : this.maxExtent}).chain(new tween.CurveTween.new({curve: this.snapConfiguration.curve})));
      this[_controller].forward({from: 0.0});
    }
    maybeStopSnapAnimation(direction) {
      let t0;
      t0 = this[_controller];
      t0 == null ? null : t0.stop();
    }
    performLayout() {
      let constraints = this.constraints;
      let maxExtent = this.maxExtent;
      if (this[_lastActualScrollOffset] != null && (dart.notNull(constraints.scrollOffset) < dart.notNull(this[_lastActualScrollOffset]) || dart.notNull(this[_effectiveScrollOffset]) < dart.notNull(maxExtent))) {
        let delta = dart.notNull(this[_lastActualScrollOffset]) - dart.notNull(constraints.scrollOffset);
        let allowFloatingExpansion = constraints.userScrollDirection == viewport_offset.ScrollDirection.forward;
        if (allowFloatingExpansion) {
          if (dart.notNull(this[_effectiveScrollOffset]) > dart.notNull(maxExtent)) this[_effectiveScrollOffset] = maxExtent;
        } else {
          if (delta > 0.0) delta = 0.0;
        }
        this[_effectiveScrollOffset] = (dart.notNull(this[_effectiveScrollOffset]) - delta)[$clamp](0.0, constraints.scrollOffset);
      } else {
        this[_effectiveScrollOffset] = constraints.scrollOffset;
      }
      let overlapsContent = dart.notNull(this[_effectiveScrollOffset]) < dart.notNull(constraints.scrollOffset);
      this.layoutChild(this[_effectiveScrollOffset], maxExtent, {overlapsContent: overlapsContent});
      this[_childPosition] = this.updateGeometry();
      this[_lastActualScrollOffset] = constraints.scrollOffset;
    }
    childMainAxisPosition(child) {
      RenderBoxL().as(child);
      if (!dart.equals(child, this.child)) dart.assertFailed(null, L0, 573, 12, "child == this.child");
      return this[_childPosition];
    }
    debugFillProperties(properties) {
      super.debugFillProperties(properties);
      properties.add(new diagnostics.DoubleProperty.new("effective scroll offset", this[_effectiveScrollOffset]));
    }
  };
  (sliver_persistent_header.RenderSliverFloatingPersistentHeader.new = function(opts) {
    let child = opts && 'child' in opts ? opts.child : null;
    let snapConfiguration = opts && 'snapConfiguration' in opts ? opts.snapConfiguration : null;
    let stretchConfiguration = opts && 'stretchConfiguration' in opts ? opts.stretchConfiguration : null;
    this[_controller] = null;
    this[_animation] = null;
    this[_lastActualScrollOffset] = null;
    this[_effectiveScrollOffset] = null;
    this[_childPosition] = null;
    this[_snapConfiguration] = snapConfiguration;
    sliver_persistent_header.RenderSliverFloatingPersistentHeader.__proto__.new.call(this, {child: child, stretchConfiguration: stretchConfiguration});
    ;
  }).prototype = sliver_persistent_header.RenderSliverFloatingPersistentHeader.prototype;
  dart.addTypeTests(sliver_persistent_header.RenderSliverFloatingPersistentHeader);
  dart.addTypeCaches(sliver_persistent_header.RenderSliverFloatingPersistentHeader);
  dart.setMethodSignature(sliver_persistent_header.RenderSliverFloatingPersistentHeader, () => ({
    __proto__: dart.getMethods(sliver_persistent_header.RenderSliverFloatingPersistentHeader.__proto__),
    updateGeometry: dart.fnType(dart.legacy(core.double), []),
    maybeStartSnapAnimation: dart.fnType(dart.void, [dart.legacy(viewport_offset.ScrollDirection)]),
    maybeStopSnapAnimation: dart.fnType(dart.void, [dart.legacy(viewport_offset.ScrollDirection)]),
    performLayout: dart.fnType(dart.void, [])
  }));
  dart.setGetterSignature(sliver_persistent_header.RenderSliverFloatingPersistentHeader, () => ({
    __proto__: dart.getGetters(sliver_persistent_header.RenderSliverFloatingPersistentHeader.__proto__),
    snapConfiguration: dart.legacy(sliver_persistent_header.FloatingHeaderSnapConfiguration)
  }));
  dart.setSetterSignature(sliver_persistent_header.RenderSliverFloatingPersistentHeader, () => ({
    __proto__: dart.getSetters(sliver_persistent_header.RenderSliverFloatingPersistentHeader.__proto__),
    snapConfiguration: dart.legacy(sliver_persistent_header.FloatingHeaderSnapConfiguration)
  }));
  dart.setLibraryUri(sliver_persistent_header.RenderSliverFloatingPersistentHeader, L1);
  dart.setFieldSignature(sliver_persistent_header.RenderSliverFloatingPersistentHeader, () => ({
    __proto__: dart.getFields(sliver_persistent_header.RenderSliverFloatingPersistentHeader.__proto__),
    [_controller]: dart.fieldType(dart.legacy(animation_controller.AnimationController)),
    [_animation]: dart.fieldType(dart.legacy(animation.Animation$(dart.legacy(core.double)))),
    [_lastActualScrollOffset]: dart.fieldType(dart.legacy(core.double)),
    [_effectiveScrollOffset]: dart.fieldType(dart.legacy(core.double)),
    [_childPosition]: dart.fieldType(dart.legacy(core.double)),
    [_snapConfiguration]: dart.fieldType(dart.legacy(sliver_persistent_header.FloatingHeaderSnapConfiguration))
  }));
  sliver_persistent_header.RenderSliverFloatingPinnedPersistentHeader = class RenderSliverFloatingPinnedPersistentHeader extends sliver_persistent_header.RenderSliverFloatingPersistentHeader {
    updateGeometry() {
      let minExtent = this.minExtent;
      let minAllowedExtent = dart.notNull(this.constraints.remainingPaintExtent) > dart.notNull(minExtent) ? minExtent : this.constraints.remainingPaintExtent;
      let maxExtent = this.maxExtent;
      let paintExtent = dart.notNull(maxExtent) - dart.notNull(this[_effectiveScrollOffset]);
      let clampedPaintExtent = paintExtent[$clamp](minAllowedExtent, this.constraints.remainingPaintExtent);
      let layoutExtent = dart.notNull(maxExtent) - dart.notNull(this.constraints.scrollOffset);
      let stretchOffset = this.stretchConfiguration != null ? this.constraints.overlap[$abs]() : 0.0;
      this.geometry = new sliver.SliverGeometry.new({scrollExtent: maxExtent, paintOrigin: math.min(doubleL(), this.constraints.overlap, 0.0), paintExtent: clampedPaintExtent, layoutExtent: layoutExtent[$clamp](0.0, clampedPaintExtent), maxPaintExtent: dart.notNull(maxExtent) + stretchOffset, maxScrollObstructionExtent: minExtent, hasVisualOverflow: true});
      return 0.0;
    }
  };
  (sliver_persistent_header.RenderSliverFloatingPinnedPersistentHeader.new = function(opts) {
    let child = opts && 'child' in opts ? opts.child : null;
    let snapConfiguration = opts && 'snapConfiguration' in opts ? opts.snapConfiguration : null;
    let stretchConfiguration = opts && 'stretchConfiguration' in opts ? opts.stretchConfiguration : null;
    sliver_persistent_header.RenderSliverFloatingPinnedPersistentHeader.__proto__.new.call(this, {child: child, snapConfiguration: snapConfiguration, stretchConfiguration: stretchConfiguration});
    ;
  }).prototype = sliver_persistent_header.RenderSliverFloatingPinnedPersistentHeader.prototype;
  dart.addTypeTests(sliver_persistent_header.RenderSliverFloatingPinnedPersistentHeader);
  dart.addTypeCaches(sliver_persistent_header.RenderSliverFloatingPinnedPersistentHeader);
  dart.setLibraryUri(sliver_persistent_header.RenderSliverFloatingPinnedPersistentHeader, L1);
  dart.trackLibraries("packages/flutter/src/rendering/sliver_persistent_header.dart", {
    "package:flutter/src/rendering/sliver_persistent_header.dart": sliver_persistent_header
  }, {
  }, '{"version":3,"sourceRoot":"","sources":["sliver_persistent_header.dart"],"names":[],"mappings":"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","file":"../../../../../../packages/flutter/src/rendering/sliver_persistent_header.dart.lib.js"}');
  // Exports:
  return {
    src__rendering__sliver_persistent_header: sliver_persistent_header
  };
}));

//# sourceMappingURL=sliver_persistent_header.dart.lib.js.map
