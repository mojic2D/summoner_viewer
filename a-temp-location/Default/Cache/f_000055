define(['dart_sdk', 'packages/flutter/src/painting/basic_types.dart', 'packages/flutter/src/rendering/layer.dart', 'packages/flutter/src/foundation/debug.dart', 'packages/flutter/src/rendering/viewport_offset.dart', 'packages/flutter/src/foundation/object.dart', 'packages/flutter/src/gestures/hit_test.dart', 'packages/vector_math/vector_math_64.dart', 'packages/flutter/src/painting/matrix_utils.dart', 'packages/flutter/src/animation/curves.dart', 'packages/flutter/src/semantics/semantics.dart'], (function load__packages__flutter__src__rendering__sliver_dart(dart_sdk, packages__flutter__src__painting__basic_types$46dart, packages__flutter__src__rendering__layer$46dart, packages__flutter__src__foundation__debug$46dart, packages__flutter__src__rendering__viewport_offset$46dart, packages__flutter__src__foundation__object$46dart, packages__flutter__src__gestures__hit_test$46dart, packages__vector_math__vector_math_64$46dart, packages__flutter__src__painting__matrix_utils$46dart, packages__flutter__src__animation__curves$46dart, packages__flutter__src__semantics__semantics$46dart) {
  'use strict';
  const core = dart_sdk.core;
  const _interceptors = dart_sdk._interceptors;
  const ui = dart_sdk.ui;
  const _js_helper = dart_sdk._js_helper;
  const math = dart_sdk.math;
  const dart = dart_sdk.dart;
  const dartx = dart_sdk.dartx;
  const basic_types = packages__flutter__src__painting__basic_types$46dart.src__painting__basic_types;
  const box = packages__flutter__src__rendering__layer$46dart.src__rendering__box;
  const object = packages__flutter__src__rendering__layer$46dart.src__rendering__object;
  const debug = packages__flutter__src__rendering__layer$46dart.src__rendering__debug;
  const assertions = packages__flutter__src__foundation__debug$46dart.src__foundation__assertions;
  const diagnostics = packages__flutter__src__foundation__debug$46dart.src__foundation__diagnostics;
  const viewport_offset = packages__flutter__src__rendering__viewport_offset$46dart.src__rendering__viewport_offset;
  const object$ = packages__flutter__src__foundation__object$46dart.src__foundation__object;
  const hit_test = packages__flutter__src__gestures__hit_test$46dart.src__gestures__hit_test;
  const vector_math_64 = packages__vector_math__vector_math_64$46dart.vector_math_64;
  const matrix_utils = packages__flutter__src__painting__matrix_utils$46dart.src__painting__matrix_utils;
  const curves = packages__flutter__src__animation__curves$46dart.src__animation__curves;
  const semantics = packages__flutter__src__semantics__semantics$46dart.src__semantics__semantics;
  var sliver$ = Object.create(dart.library);
  var viewport = Object.create(dart.library);
  var $toString = dartx.toString;
  var $isNaN = dartx.isNaN;
  var $add = dartx.add;
  var $toStringAsFixed = dartx.toStringAsFixed;
  var $join = dartx.join;
  var $_equals = dartx._equals;
  var $hashCode = dartx.hashCode;
  var $clamp = dartx.clamp;
  var $isFinite = dartx.isFinite;
  var $where = dartx.where;
  var $forEach = dartx.forEach;
  var $abs = dartx.abs;
  var GrowthDirectionL = () => (GrowthDirectionL = dart.constFn(dart.legacy(sliver$.GrowthDirection)))();
  var boolL = () => (boolL = dart.constFn(dart.legacy(core.bool)))();
  var StringL = () => (StringL = dart.constFn(dart.legacy(core.String)))();
  var boolLAndStringLTovoid = () => (boolLAndStringLTovoid = dart.constFn(dart.fnType(dart.void, [boolL(), StringL()])))();
  var doubleL = () => (doubleL = dart.constFn(dart.legacy(core.double)))();
  var doubleLAndStringL__Tovoid = () => (doubleLAndStringL__Tovoid = dart.constFn(dart.fnType(dart.void, [doubleL(), StringL()], {mustBeNegative: boolL(), mustBePositive: boolL()}, {})))();
  var DiagnosticsNodeL = () => (DiagnosticsNodeL = dart.constFn(dart.legacy(diagnostics.DiagnosticsNode)))();
  var JSArrayOfDiagnosticsNodeL = () => (JSArrayOfDiagnosticsNodeL = dart.constFn(_interceptors.JSArray$(DiagnosticsNodeL())))();
  var SliverConstraintsL = () => (SliverConstraintsL = dart.constFn(dart.legacy(sliver$.SliverConstraints)))();
  var DiagnosticsPropertyOfSliverConstraintsL = () => (DiagnosticsPropertyOfSliverConstraintsL = dart.constFn(diagnostics.DiagnosticsProperty$(SliverConstraintsL())))();
  var VoidToboolL = () => (VoidToboolL = dart.constFn(dart.fnType(boolL(), [])))();
  var JSArrayOfStringL = () => (JSArrayOfStringL = dart.constFn(_interceptors.JSArray$(StringL())))();
  var ListOfDiagnosticsNodeL = () => (ListOfDiagnosticsNodeL = dart.constFn(core.List$(DiagnosticsNodeL())))();
  var ListLOfDiagnosticsNodeL = () => (ListLOfDiagnosticsNodeL = dart.constFn(dart.legacy(ListOfDiagnosticsNodeL())))();
  var boolLAndStringL__Tovoid = () => (boolLAndStringL__Tovoid = dart.constFn(dart.fnType(dart.void, [boolL(), StringL()], {details: ListLOfDiagnosticsNodeL()}, {})))();
  var DiagnosticsPropertyOfboolL = () => (DiagnosticsPropertyOfboolL = dart.constFn(diagnostics.DiagnosticsProperty$(boolL())))();
  var RenderSliverL = () => (RenderSliverL = dart.constFn(dart.legacy(sliver$.RenderSliver)))();
  var SyncIterableOfDiagnosticsNodeL = () => (SyncIterableOfDiagnosticsNodeL = dart.constFn(_js_helper.SyncIterable$(DiagnosticsNodeL())))();
  var IterableOfDiagnosticsNodeL = () => (IterableOfDiagnosticsNodeL = dart.constFn(core.Iterable$(DiagnosticsNodeL())))();
  var IterableLOfDiagnosticsNodeL = () => (IterableLOfDiagnosticsNodeL = dart.constFn(dart.legacy(IterableOfDiagnosticsNodeL())))();
  var VoidToIterableLOfDiagnosticsNodeL = () => (VoidToIterableLOfDiagnosticsNodeL = dart.constFn(dart.fnType(IterableLOfDiagnosticsNodeL(), [])))();
  var RenderObjectL = () => (RenderObjectL = dart.constFn(dart.legacy(object.RenderObject)))();
  var VoidToNullN = () => (VoidToNullN = dart.constFn(dart.fnType(core.Null, [])))();
  var SliverHitTestEntryL = () => (SliverHitTestEntryL = dart.constFn(dart.legacy(sliver$.SliverHitTestEntry)))();
  var SliverGeometryL = () => (SliverGeometryL = dart.constFn(dart.legacy(sliver$.SliverGeometry)))();
  var DiagnosticsPropertyOfSliverGeometryL = () => (DiagnosticsPropertyOfSliverGeometryL = dart.constFn(diagnostics.DiagnosticsProperty$(SliverGeometryL())))();
  var BoxHitTestResultL = () => (BoxHitTestResultL = dart.constFn(dart.legacy(box.BoxHitTestResult)))();
  var OffsetL = () => (OffsetL = dart.constFn(dart.legacy(ui.Offset)))();
  var BoxHitTestResultLAndOffsetLToboolL = () => (BoxHitTestResultLAndOffsetLToboolL = dart.constFn(dart.fnType(boolL(), [BoxHitTestResultL(), OffsetL()])))();
  var SliverPhysicalParentDataL = () => (SliverPhysicalParentDataL = dart.constFn(dart.legacy(sliver$.SliverPhysicalParentData)))();
  var RenderBoxL = () => (RenderBoxL = dart.constFn(dart.legacy(box.RenderBox)))();
  var CacheExtentStyleL = () => (CacheExtentStyleL = dart.constFn(dart.legacy(viewport.CacheExtentStyle)))();
  var RenderAbstractViewportL = () => (RenderAbstractViewportL = dart.constFn(dart.legacy(viewport.RenderAbstractViewport)))();
  var RenderSliverLToboolL = () => (RenderSliverLToboolL = dart.constFn(dart.fnType(boolL(), [RenderSliverL()])))();
  var PipelineOwnerL = () => (PipelineOwnerL = dart.constFn(dart.legacy(object.PipelineOwner)))();
  var RenderShrinkWrappingViewportL = () => (RenderShrinkWrappingViewportL = dart.constFn(dart.legacy(viewport.RenderShrinkWrappingViewport)))();
  var AxisDirectionL = () => (AxisDirectionL = dart.constFn(dart.legacy(basic_types.AxisDirection)))();
  var EnumPropertyOfAxisDirectionL = () => (EnumPropertyOfAxisDirectionL = dart.constFn(diagnostics.EnumProperty$(AxisDirectionL())))();
  var ViewportOffsetL = () => (ViewportOffsetL = dart.constFn(dart.legacy(viewport_offset.ViewportOffset)))();
  var DiagnosticsPropertyOfViewportOffsetL = () => (DiagnosticsPropertyOfViewportOffsetL = dart.constFn(diagnostics.DiagnosticsProperty$(ViewportOffsetL())))();
  var SliverPhysicalContainerParentDataL = () => (SliverPhysicalContainerParentDataL = dart.constFn(dart.legacy(sliver$.SliverPhysicalContainerParentData)))();
  var SyncIterableOfRenderSliverL = () => (SyncIterableOfRenderSliverL = dart.constFn(_js_helper.SyncIterable$(RenderSliverL())))();
  var SliverLogicalContainerParentDataL = () => (SliverLogicalContainerParentDataL = dart.constFn(dart.legacy(sliver$.SliverLogicalContainerParentData)))();
  var SliverLogicalParentDataL = () => (SliverLogicalParentDataL = dart.constFn(dart.legacy(sliver$.SliverLogicalParentData)))();
  const CT = Object.create(null);
  var L1 = "file:///C:/flutter/packages/flutter/lib/src/rendering/sliver.dart";
  var L3 = "file:///C:/flutter/packages/flutter/lib/src/rendering/viewport.dart";
  var L0 = "package:flutter/src/rendering/sliver.dart";
  var L2 = "package:flutter/src/rendering/viewport.dart";
  dart.defineLazy(CT, {
    get C0() {
      return C0 = dart.const({
        __proto__: sliver$.GrowthDirection.prototype,
        [_name$]: "GrowthDirection.forward",
        index: 0
      });
    },
    get C1() {
      return C1 = dart.const({
        __proto__: sliver$.GrowthDirection.prototype,
        [_name$]: "GrowthDirection.reverse",
        index: 1
      });
    },
    get C2() {
      return C2 = dart.constList([C0 || CT.C0, C1 || CT.C1], GrowthDirectionL());
    },
    get C3() {
      return C3 = dart.const({
        __proto__: basic_types.AxisDirection.prototype,
        [_name]: "AxisDirection.down",
        index: 2
      });
    },
    get C4() {
      return C4 = dart.const({
        __proto__: basic_types.AxisDirection.prototype,
        [_name]: "AxisDirection.right",
        index: 1
      });
    },
    get C5() {
      return C5 = dart.const({
        __proto__: basic_types.AxisDirection.prototype,
        [_name]: "AxisDirection.up",
        index: 0
      });
    },
    get C6() {
      return C6 = dart.const({
        __proto__: basic_types.AxisDirection.prototype,
        [_name]: "AxisDirection.left",
        index: 3
      });
    },
    get C7() {
      return C7 = dart.const({
        __proto__: basic_types.Axis.prototype,
        [_name]: "Axis.horizontal",
        index: 0
      });
    },
    get C8() {
      return C8 = dart.const({
        __proto__: basic_types.Axis.prototype,
        [_name]: "Axis.vertical",
        index: 1
      });
    },
    get C9() {
      return C9 = dart.const({
        __proto__: sliver$.SliverGeometry.prototype,
        [cacheExtent$]: 0,
        [scrollOffsetCorrection$]: null,
        [hasVisualOverflow$]: false,
        [visible$]: false,
        [hitTestExtent$]: 0,
        [maxScrollObstructionExtent$]: 0,
        [maxPaintExtent$]: 0,
        [layoutExtent$]: 0,
        [paintExtent$]: 0,
        [paintOrigin$]: 0,
        [scrollExtent$]: 0
      });
    },
    get C10() {
      return C10 = dart.const({
        __proto__: ui.Color.prototype,
        [Color_value]: 4281584691.0
      });
    },
    get C11() {
      return C11 = dart.const({
        __proto__: viewport.CacheExtentStyle.prototype,
        [_name$0]: "CacheExtentStyle.pixel",
        index: 0
      });
    },
    get C12() {
      return C12 = dart.const({
        __proto__: viewport.CacheExtentStyle.prototype,
        [_name$0]: "CacheExtentStyle.viewport",
        index: 1
      });
    },
    get C13() {
      return C13 = dart.constList([C11 || CT.C11, C12 || CT.C12], CacheExtentStyleL());
    },
    get C14() {
      return C14 = dart.const({
        __proto__: ui.Clip.prototype,
        [_name$1]: "Clip.hardEdge",
        index: 1
      });
    },
    get C15() {
      return C15 = dart.const({
        __proto__: ui.Color.prototype,
        [Color_value]: 4278255360.0
      });
    },
    get C16() {
      return C16 = dart.const({
        __proto__: core.Duration.prototype,
        [Duration__duration]: 0
      });
    },
    get C17() {
      return C17 = dart.const({
        __proto__: curves.Cubic.prototype,
        [Cubic_d]: 1,
        [Cubic_c]: 0.25,
        [Cubic_b]: 0.1,
        [Cubic_a]: 0.25
      });
    },
    get C18() {
      return C18 = dart.const({
        __proto__: semantics.SemanticsTag.prototype,
        [SemanticsTag_name]: "RenderViewport.twoPane"
      });
    },
    get C19() {
      return C19 = dart.const({
        __proto__: semantics.SemanticsTag.prototype,
        [SemanticsTag_name]: "RenderViewport.excludeFromScrolling"
      });
    }
  }, false);
  var _name$ = dart.privateName(sliver$, "_name");
  var C0;
  var C1;
  var C2;
  sliver$.GrowthDirection = class GrowthDirection extends core.Object {
    toString() {
      return this[_name$];
    }
  };
  (sliver$.GrowthDirection.new = function(index, _name) {
    this.index = index;
    this[_name$] = _name;
    ;
  }).prototype = sliver$.GrowthDirection.prototype;
  dart.addTypeTests(sliver$.GrowthDirection);
  dart.addTypeCaches(sliver$.GrowthDirection);
  dart.setMethodSignature(sliver$.GrowthDirection, () => ({
    __proto__: dart.getMethods(sliver$.GrowthDirection.__proto__),
    toString: dart.fnType(dart.legacy(core.String), []),
    [$toString]: dart.fnType(dart.legacy(core.String), [])
  }));
  dart.setLibraryUri(sliver$.GrowthDirection, L0);
  dart.setFieldSignature(sliver$.GrowthDirection, () => ({
    __proto__: dart.getFields(sliver$.GrowthDirection.__proto__),
    index: dart.finalFieldType(dart.legacy(core.int)),
    [_name$]: dart.finalFieldType(dart.legacy(core.String))
  }));
  dart.defineExtensionMethods(sliver$.GrowthDirection, ['toString']);
  sliver$.GrowthDirection.forward = C0 || CT.C0;
  sliver$.GrowthDirection.reverse = C1 || CT.C1;
  sliver$.GrowthDirection.values = C2 || CT.C2;
  var _name = dart.privateName(basic_types, "_name");
  var C3;
  var C4;
  var C5;
  var C6;
  var C7;
  var C8;
  var axisDirection$ = dart.privateName(sliver$, "SliverConstraints.axisDirection");
  var growthDirection$ = dart.privateName(sliver$, "SliverConstraints.growthDirection");
  var userScrollDirection$ = dart.privateName(sliver$, "SliverConstraints.userScrollDirection");
  var scrollOffset$ = dart.privateName(sliver$, "SliverConstraints.scrollOffset");
  var precedingScrollExtent$ = dart.privateName(sliver$, "SliverConstraints.precedingScrollExtent");
  var overlap$ = dart.privateName(sliver$, "SliverConstraints.overlap");
  var remainingPaintExtent$ = dart.privateName(sliver$, "SliverConstraints.remainingPaintExtent");
  var crossAxisExtent$ = dart.privateName(sliver$, "SliverConstraints.crossAxisExtent");
  var crossAxisDirection$ = dart.privateName(sliver$, "SliverConstraints.crossAxisDirection");
  var viewportMainAxisExtent$ = dart.privateName(sliver$, "SliverConstraints.viewportMainAxisExtent");
  var cacheOrigin$ = dart.privateName(sliver$, "SliverConstraints.cacheOrigin");
  var remainingCacheExtent$ = dart.privateName(sliver$, "SliverConstraints.remainingCacheExtent");
  sliver$.SliverConstraints = class SliverConstraints extends object.Constraints {
    get axisDirection() {
      return this[axisDirection$];
    }
    set axisDirection(value) {
      super.axisDirection = value;
    }
    get growthDirection() {
      return this[growthDirection$];
    }
    set growthDirection(value) {
      super.growthDirection = value;
    }
    get userScrollDirection() {
      return this[userScrollDirection$];
    }
    set userScrollDirection(value) {
      super.userScrollDirection = value;
    }
    get scrollOffset() {
      return this[scrollOffset$];
    }
    set scrollOffset(value) {
      super.scrollOffset = value;
    }
    get precedingScrollExtent() {
      return this[precedingScrollExtent$];
    }
    set precedingScrollExtent(value) {
      super.precedingScrollExtent = value;
    }
    get overlap() {
      return this[overlap$];
    }
    set overlap(value) {
      super.overlap = value;
    }
    get remainingPaintExtent() {
      return this[remainingPaintExtent$];
    }
    set remainingPaintExtent(value) {
      super.remainingPaintExtent = value;
    }
    get crossAxisExtent() {
      return this[crossAxisExtent$];
    }
    set crossAxisExtent(value) {
      super.crossAxisExtent = value;
    }
    get crossAxisDirection() {
      return this[crossAxisDirection$];
    }
    set crossAxisDirection(value) {
      super.crossAxisDirection = value;
    }
    get viewportMainAxisExtent() {
      return this[viewportMainAxisExtent$];
    }
    set viewportMainAxisExtent(value) {
      super.viewportMainAxisExtent = value;
    }
    get cacheOrigin() {
      return this[cacheOrigin$];
    }
    set cacheOrigin(value) {
      super.cacheOrigin = value;
    }
    get remainingCacheExtent() {
      return this[remainingCacheExtent$];
    }
    set remainingCacheExtent(value) {
      super.remainingCacheExtent = value;
    }
    copyWith(opts) {
      let t0, t0$, t0$0, t0$1, t0$2, t0$3, t0$4, t0$5, t0$6, t0$7, t0$8, t0$9;
      let axisDirection = opts && 'axisDirection' in opts ? opts.axisDirection : null;
      let growthDirection = opts && 'growthDirection' in opts ? opts.growthDirection : null;
      let userScrollDirection = opts && 'userScrollDirection' in opts ? opts.userScrollDirection : null;
      let scrollOffset = opts && 'scrollOffset' in opts ? opts.scrollOffset : null;
      let precedingScrollExtent = opts && 'precedingScrollExtent' in opts ? opts.precedingScrollExtent : null;
      let overlap = opts && 'overlap' in opts ? opts.overlap : null;
      let remainingPaintExtent = opts && 'remainingPaintExtent' in opts ? opts.remainingPaintExtent : null;
      let crossAxisExtent = opts && 'crossAxisExtent' in opts ? opts.crossAxisExtent : null;
      let crossAxisDirection = opts && 'crossAxisDirection' in opts ? opts.crossAxisDirection : null;
      let viewportMainAxisExtent = opts && 'viewportMainAxisExtent' in opts ? opts.viewportMainAxisExtent : null;
      let remainingCacheExtent = opts && 'remainingCacheExtent' in opts ? opts.remainingCacheExtent : null;
      let cacheOrigin = opts && 'cacheOrigin' in opts ? opts.cacheOrigin : null;
      return new sliver$.SliverConstraints.new({axisDirection: (t0 = axisDirection, t0 == null ? this.axisDirection : t0), growthDirection: (t0$ = growthDirection, t0$ == null ? this.growthDirection : t0$), userScrollDirection: (t0$0 = userScrollDirection, t0$0 == null ? this.userScrollDirection : t0$0), scrollOffset: (t0$1 = scrollOffset, t0$1 == null ? this.scrollOffset : t0$1), precedingScrollExtent: (t0$2 = precedingScrollExtent, t0$2 == null ? this.precedingScrollExtent : t0$2), overlap: (t0$3 = overlap, t0$3 == null ? this.overlap : t0$3), remainingPaintExtent: (t0$4 = remainingPaintExtent, t0$4 == null ? this.remainingPaintExtent : t0$4), crossAxisExtent: (t0$5 = crossAxisExtent, t0$5 == null ? this.crossAxisExtent : t0$5), crossAxisDirection: (t0$6 = crossAxisDirection, t0$6 == null ? this.crossAxisDirection : t0$6), viewportMainAxisExtent: (t0$7 = viewportMainAxisExtent, t0$7 == null ? this.viewportMainAxisExtent : t0$7), remainingCacheExtent: (t0$8 = remainingCacheExtent, t0$8 == null ? this.remainingCacheExtent : t0$8), cacheOrigin: (t0$9 = cacheOrigin, t0$9 == null ? this.cacheOrigin : t0$9)});
    }
    get axis() {
      return basic_types.axisDirectionToAxis(this.axisDirection);
    }
    get normalizedGrowthDirection() {
      if (!(this.axisDirection != null)) dart.assertFailed(null, L1, 350, 12, "axisDirection != null");
      switch (this.axisDirection) {
        case C3 || CT.C3:
        case C4 || CT.C4:
        {
          return this.growthDirection;
        }
        case C5 || CT.C5:
        case C6 || CT.C6:
        {
          switch (this.growthDirection) {
            case C0 || CT.C0:
            {
              return sliver$.GrowthDirection.reverse;
            }
            case C1 || CT.C1:
            {
              return sliver$.GrowthDirection.forward;
            }
          }
          return null;
        }
      }
      return null;
    }
    get isTight() {
      return false;
    }
    get isNormalized() {
      return dart.notNull(this.scrollOffset) >= 0.0 && dart.notNull(this.crossAxisExtent) >= 0.0 && basic_types.axisDirectionToAxis(this.axisDirection) != basic_types.axisDirectionToAxis(this.crossAxisDirection) && dart.notNull(this.viewportMainAxisExtent) >= 0.0 && dart.notNull(this.remainingPaintExtent) >= 0.0;
    }
    asBoxConstraints(opts) {
      let minExtent = opts && 'minExtent' in opts ? opts.minExtent : 0;
      let maxExtent = opts && 'maxExtent' in opts ? opts.maxExtent : 1 / 0;
      let crossAxisExtent = opts && 'crossAxisExtent' in opts ? opts.crossAxisExtent : null;
      crossAxisExtent == null ? crossAxisExtent = this.crossAxisExtent : null;
      switch (this.axis) {
        case C7 || CT.C7:
        {
          return new box.BoxConstraints.new({minHeight: crossAxisExtent, maxHeight: crossAxisExtent, minWidth: minExtent, maxWidth: maxExtent});
        }
        case C8 || CT.C8:
        {
          return new box.BoxConstraints.new({minWidth: crossAxisExtent, maxWidth: crossAxisExtent, minHeight: minExtent, maxHeight: maxExtent});
        }
      }
      return null;
    }
    debugAssertIsValid(opts) {
      let isAppliedConstraint = opts && 'isAppliedConstraint' in opts ? opts.isAppliedConstraint : false;
      let informationCollector = opts && 'informationCollector' in opts ? opts.informationCollector : null;
      if (!dart.test(dart.fn(() => {
        let hasErrors = false;
        let errorMessage = new core.StringBuffer.new("\n");
        function verify(check, message) {
          if (dart.test(check)) return;
          hasErrors = true;
          errorMessage.writeln("  " + dart.str(message));
        }
        dart.fn(verify, boolLAndStringLTovoid());
        function verifyDouble(property, name, opts) {
          let mustBeNegative = opts && 'mustBeNegative' in opts ? opts.mustBeNegative : false;
          let mustBePositive = opts && 'mustBePositive' in opts ? opts.mustBePositive : false;
          verify(property != null, "The \"" + dart.str(name) + "\" is null.");
          if (property[$isNaN]) {
            let additional = ".";
            if (dart.test(mustBePositive)) {
              additional = ", expected greater than or equal to zero.";
            } else if (dart.test(mustBeNegative)) {
              additional = ", expected less than or equal to zero.";
            }
            verify(false, "The \"" + dart.str(name) + "\" is NaN" + additional);
          } else if (dart.test(mustBePositive)) {
            verify(dart.notNull(property) >= 0.0, "The \"" + dart.str(name) + "\" is negative.");
          } else if (dart.test(mustBeNegative)) {
            verify(dart.notNull(property) <= 0.0, "The \"" + dart.str(name) + "\" is positive.");
          }
        }
        dart.fn(verifyDouble, doubleLAndStringL__Tovoid());
        verify(this.axis != null, "The \"axis\" is null.");
        verify(this.growthDirection != null, "The \"growthDirection\" is null.");
        verifyDouble(this.scrollOffset, "scrollOffset");
        verifyDouble(this.overlap, "overlap");
        verifyDouble(this.crossAxisExtent, "crossAxisExtent");
        verifyDouble(this.scrollOffset, "scrollOffset", {mustBePositive: true});
        verify(this.crossAxisDirection != null, "The \"crossAxisDirection\" is null.");
        verify(basic_types.axisDirectionToAxis(this.axisDirection) != basic_types.axisDirectionToAxis(this.crossAxisDirection), "The \"axisDirection\" and the \"crossAxisDirection\" are along the same axis.");
        verifyDouble(this.viewportMainAxisExtent, "viewportMainAxisExtent", {mustBePositive: true});
        verifyDouble(this.remainingPaintExtent, "remainingPaintExtent", {mustBePositive: true});
        verifyDouble(this.remainingCacheExtent, "remainingCacheExtent", {mustBePositive: true});
        verifyDouble(this.cacheOrigin, "cacheOrigin", {mustBeNegative: true});
        verifyDouble(this.precedingScrollExtent, "precedingScrollExtent", {mustBePositive: true});
        verify(this.isNormalized, "The constraints are not normalized.");
        if (hasErrors) {
          dart.throw(new assertions.FlutterError.fromParts((() => {
            let t0 = JSArrayOfDiagnosticsNodeL().of([]);
            t0[$add](new assertions.ErrorSummary.new(dart.str(this.runtimeType) + " is not valid: " + dart.str(errorMessage)));
            if (informationCollector != null) for (let t1 of informationCollector())
              t0[$add](t1);
            t0[$add](new (DiagnosticsPropertyOfSliverConstraintsL()).new("The offending constraints were", this, {style: diagnostics.DiagnosticsTreeStyle.errorProperty}));
            return t0;
          })()));
        }
        return true;
      }, VoidToboolL())())) dart.assertFailed(null, L1, 418, 12, "() {\r\n      bool hasErrors = false;\r\n      final StringBuffer errorMessage = StringBuffer('\\n');\r\n      void verify(bool check, String message) {\r\n        if (check)\r\n          return;\r\n        hasErrors = true;\r\n        errorMessage.writeln('  $message');\r\n      }\r\n      void verifyDouble(double property, String name, {bool mustBePositive = false, bool mustBeNegative = false}) {\r\n        verify(property != null, 'The \"$name\" is null.');\r\n        if (property.isNaN) {\r\n          String additional = '.';\r\n          if (mustBePositive) {\r\n            additional = ', expected greater than or equal to zero.';\r\n          } else if (mustBeNegative) {\r\n            additional = ', expected less than or equal to zero.';\r\n          }\r\n          verify(false, 'The \"$name\" is NaN$additional');\r\n        } else if (mustBePositive) {\r\n          verify(property >= 0.0, 'The \"$name\" is negative.');\r\n        } else if (mustBeNegative) {\r\n          verify(property <= 0.0, 'The \"$name\" is positive.');\r\n        }\r\n      }\r\n      verify(axis != null, 'The \"axis\" is null.');\r\n      verify(growthDirection != null, 'The \"growthDirection\" is null.');\r\n      verifyDouble(scrollOffset, 'scrollOffset');\r\n      verifyDouble(overlap, 'overlap');\r\n      verifyDouble(crossAxisExtent, 'crossAxisExtent');\r\n      verifyDouble(scrollOffset, 'scrollOffset', mustBePositive: true);\r\n      verify(crossAxisDirection != null, 'The \"crossAxisDirection\" is null.');\r\n      verify(axisDirectionToAxis(axisDirection) != axisDirectionToAxis(crossAxisDirection), 'The \"axisDirection\" and the \"crossAxisDirection\" are along the same axis.');\r\n      verifyDouble(viewportMainAxisExtent, 'viewportMainAxisExtent', mustBePositive: true);\r\n      verifyDouble(remainingPaintExtent, 'remainingPaintExtent', mustBePositive: true);\r\n      verifyDouble(remainingCacheExtent, 'remainingCacheExtent', mustBePositive: true);\r\n      verifyDouble(cacheOrigin, 'cacheOrigin', mustBeNegative: true);\r\n      verifyDouble(precedingScrollExtent, 'precedingScrollExtent', mustBePositive: true);\r\n      verify(isNormalized, 'The constraints are not normalized.'); // should be redundant with earlier checks\r\n      if (hasErrors) {\r\n        throw FlutterError.fromParts(<DiagnosticsNode>[\r\n          ErrorSummary('$runtimeType is not valid: $errorMessage'),\r\n          if (informationCollector != null)\r\n            ...informationCollector(),\r\n          DiagnosticsProperty<SliverConstraints>('The offending constraints were', this, style: DiagnosticsTreeStyle.errorProperty),\r\n        ]);\r\n      }\r\n      return true;\r\n    }()");
      return true;
    }
    _equals(other) {
      if (other == null) return false;
      if (this === other) return true;
      if (!SliverConstraintsL().is(other)) return false;
      if (!(SliverConstraintsL().is(other) && dart.test(other.debugAssertIsValid()))) dart.assertFailed(null, L1, 476, 12, "other is SliverConstraints && other.debugAssertIsValid()");
      return SliverConstraintsL().is(other) && other.axisDirection == this.axisDirection && other.growthDirection == this.growthDirection && other.scrollOffset == this.scrollOffset && other.overlap == this.overlap && other.remainingPaintExtent == this.remainingPaintExtent && other.crossAxisExtent == this.crossAxisExtent && other.crossAxisDirection == this.crossAxisDirection && other.viewportMainAxisExtent == this.viewportMainAxisExtent && other.remainingCacheExtent == this.remainingCacheExtent && other.cacheOrigin == this.cacheOrigin;
    }
    get hashCode() {
      return ui.hashValues(this.axisDirection, this.growthDirection, this.scrollOffset, this.overlap, this.remainingPaintExtent, this.crossAxisExtent, this.crossAxisDirection, this.viewportMainAxisExtent, this.remainingCacheExtent, this.cacheOrigin);
    }
    toString() {
      let properties = (() => {
        let t2 = JSArrayOfStringL().of([]);
        t2[$add](dart.str(this.axisDirection));
        t2[$add](dart.str(this.growthDirection));
        t2[$add](dart.str(this.userScrollDirection));
        t2[$add]("scrollOffset: " + dart.str(this.scrollOffset[$toStringAsFixed](1)));
        t2[$add]("remainingPaintExtent: " + dart.str(this.remainingPaintExtent[$toStringAsFixed](1)));
        if (this.overlap !== 0.0) t2[$add]("overlap: " + dart.str(this.overlap[$toStringAsFixed](1)));
        t2[$add]("crossAxisExtent: " + dart.str(this.crossAxisExtent[$toStringAsFixed](1)));
        t2[$add]("crossAxisDirection: " + dart.str(this.crossAxisDirection));
        t2[$add]("viewportMainAxisExtent: " + dart.str(this.viewportMainAxisExtent[$toStringAsFixed](1)));
        t2[$add]("remainingCacheExtent: " + dart.str(this.remainingCacheExtent[$toStringAsFixed](1)));
        t2[$add]("cacheOrigin: " + dart.str(this.cacheOrigin[$toStringAsFixed](1)));
        return t2;
      })();
      return "SliverConstraints(" + dart.str(properties[$join](", ")) + ")";
    }
  };
  (sliver$.SliverConstraints.new = function(opts) {
    let axisDirection = opts && 'axisDirection' in opts ? opts.axisDirection : null;
    let growthDirection = opts && 'growthDirection' in opts ? opts.growthDirection : null;
    let userScrollDirection = opts && 'userScrollDirection' in opts ? opts.userScrollDirection : null;
    let scrollOffset = opts && 'scrollOffset' in opts ? opts.scrollOffset : null;
    let precedingScrollExtent = opts && 'precedingScrollExtent' in opts ? opts.precedingScrollExtent : null;
    let overlap = opts && 'overlap' in opts ? opts.overlap : null;
    let remainingPaintExtent = opts && 'remainingPaintExtent' in opts ? opts.remainingPaintExtent : null;
    let crossAxisExtent = opts && 'crossAxisExtent' in opts ? opts.crossAxisExtent : null;
    let crossAxisDirection = opts && 'crossAxisDirection' in opts ? opts.crossAxisDirection : null;
    let viewportMainAxisExtent = opts && 'viewportMainAxisExtent' in opts ? opts.viewportMainAxisExtent : null;
    let remainingCacheExtent = opts && 'remainingCacheExtent' in opts ? opts.remainingCacheExtent : null;
    let cacheOrigin = opts && 'cacheOrigin' in opts ? opts.cacheOrigin : null;
    this[axisDirection$] = axisDirection;
    this[growthDirection$] = growthDirection;
    this[userScrollDirection$] = userScrollDirection;
    this[scrollOffset$] = scrollOffset;
    this[precedingScrollExtent$] = precedingScrollExtent;
    this[overlap$] = overlap;
    this[remainingPaintExtent$] = remainingPaintExtent;
    this[crossAxisExtent$] = crossAxisExtent;
    this[crossAxisDirection$] = crossAxisDirection;
    this[viewportMainAxisExtent$] = viewportMainAxisExtent;
    this[remainingCacheExtent$] = remainingCacheExtent;
    this[cacheOrigin$] = cacheOrigin;
    if (!(axisDirection != null)) dart.assertFailed(null, L1, 112, 15, "axisDirection != null");
    if (!(growthDirection != null)) dart.assertFailed(null, L1, 113, 15, "growthDirection != null");
    if (!(userScrollDirection != null)) dart.assertFailed(null, L1, 114, 15, "userScrollDirection != null");
    if (!(scrollOffset != null)) dart.assertFailed(null, L1, 115, 15, "scrollOffset != null");
    if (!(precedingScrollExtent != null)) dart.assertFailed(null, L1, 116, 15, "precedingScrollExtent != null");
    if (!(overlap != null)) dart.assertFailed(null, L1, 117, 15, "overlap != null");
    if (!(remainingPaintExtent != null)) dart.assertFailed(null, L1, 118, 15, "remainingPaintExtent != null");
    if (!(crossAxisExtent != null)) dart.assertFailed(null, L1, 119, 15, "crossAxisExtent != null");
    if (!(crossAxisDirection != null)) dart.assertFailed(null, L1, 120, 15, "crossAxisDirection != null");
    if (!(viewportMainAxisExtent != null)) dart.assertFailed(null, L1, 121, 15, "viewportMainAxisExtent != null");
    if (!(remainingCacheExtent != null)) dart.assertFailed(null, L1, 122, 15, "remainingCacheExtent != null");
    if (!(cacheOrigin != null)) dart.assertFailed(null, L1, 123, 15, "cacheOrigin != null");
    sliver$.SliverConstraints.__proto__.new.call(this);
    ;
  }).prototype = sliver$.SliverConstraints.prototype;
  dart.addTypeTests(sliver$.SliverConstraints);
  dart.addTypeCaches(sliver$.SliverConstraints);
  dart.setMethodSignature(sliver$.SliverConstraints, () => ({
    __proto__: dart.getMethods(sliver$.SliverConstraints.__proto__),
    copyWith: dart.fnType(dart.legacy(sliver$.SliverConstraints), [], {axisDirection: dart.legacy(basic_types.AxisDirection), cacheOrigin: dart.legacy(core.double), crossAxisDirection: dart.legacy(basic_types.AxisDirection), crossAxisExtent: dart.legacy(core.double), growthDirection: dart.legacy(sliver$.GrowthDirection), overlap: dart.legacy(core.double), precedingScrollExtent: dart.legacy(core.double), remainingCacheExtent: dart.legacy(core.double), remainingPaintExtent: dart.legacy(core.double), scrollOffset: dart.legacy(core.double), userScrollDirection: dart.legacy(viewport_offset.ScrollDirection), viewportMainAxisExtent: dart.legacy(core.double)}, {}),
    asBoxConstraints: dart.fnType(dart.legacy(box.BoxConstraints), [], {crossAxisExtent: dart.legacy(core.double), maxExtent: dart.legacy(core.double), minExtent: dart.legacy(core.double)}, {}),
    _equals: dart.fnType(dart.legacy(core.bool), [dart.legacy(core.Object)]),
    [$_equals]: dart.fnType(dart.legacy(core.bool), [dart.legacy(core.Object)]),
    toString: dart.fnType(dart.legacy(core.String), []),
    [$toString]: dart.fnType(dart.legacy(core.String), [])
  }));
  dart.setGetterSignature(sliver$.SliverConstraints, () => ({
    __proto__: dart.getGetters(sliver$.SliverConstraints.__proto__),
    axis: dart.legacy(basic_types.Axis),
    normalizedGrowthDirection: dart.legacy(sliver$.GrowthDirection),
    isTight: dart.legacy(core.bool),
    isNormalized: dart.legacy(core.bool),
    hashCode: dart.legacy(core.int),
    [$hashCode]: dart.legacy(core.int)
  }));
  dart.setLibraryUri(sliver$.SliverConstraints, L0);
  dart.setFieldSignature(sliver$.SliverConstraints, () => ({
    __proto__: dart.getFields(sliver$.SliverConstraints.__proto__),
    axisDirection: dart.finalFieldType(dart.legacy(basic_types.AxisDirection)),
    growthDirection: dart.finalFieldType(dart.legacy(sliver$.GrowthDirection)),
    userScrollDirection: dart.finalFieldType(dart.legacy(viewport_offset.ScrollDirection)),
    scrollOffset: dart.finalFieldType(dart.legacy(core.double)),
    precedingScrollExtent: dart.finalFieldType(dart.legacy(core.double)),
    overlap: dart.finalFieldType(dart.legacy(core.double)),
    remainingPaintExtent: dart.finalFieldType(dart.legacy(core.double)),
    crossAxisExtent: dart.finalFieldType(dart.legacy(core.double)),
    crossAxisDirection: dart.finalFieldType(dart.legacy(basic_types.AxisDirection)),
    viewportMainAxisExtent: dart.finalFieldType(dart.legacy(core.double)),
    cacheOrigin: dart.finalFieldType(dart.legacy(core.double)),
    remainingCacheExtent: dart.finalFieldType(dart.legacy(core.double))
  }));
  dart.defineExtensionMethods(sliver$.SliverConstraints, ['_equals', 'toString']);
  dart.defineExtensionAccessors(sliver$.SliverConstraints, ['hashCode']);
  var scrollExtent$ = dart.privateName(sliver$, "SliverGeometry.scrollExtent");
  var paintOrigin$ = dart.privateName(sliver$, "SliverGeometry.paintOrigin");
  var paintExtent$ = dart.privateName(sliver$, "SliverGeometry.paintExtent");
  var layoutExtent$ = dart.privateName(sliver$, "SliverGeometry.layoutExtent");
  var maxPaintExtent$ = dart.privateName(sliver$, "SliverGeometry.maxPaintExtent");
  var maxScrollObstructionExtent$ = dart.privateName(sliver$, "SliverGeometry.maxScrollObstructionExtent");
  var hitTestExtent$ = dart.privateName(sliver$, "SliverGeometry.hitTestExtent");
  var visible$ = dart.privateName(sliver$, "SliverGeometry.visible");
  var hasVisualOverflow$ = dart.privateName(sliver$, "SliverGeometry.hasVisualOverflow");
  var scrollOffsetCorrection$ = dart.privateName(sliver$, "SliverGeometry.scrollOffsetCorrection");
  var cacheExtent$ = dart.privateName(sliver$, "SliverGeometry.cacheExtent");
  var C9;
  const Object_Diagnosticable$36 = class Object_Diagnosticable extends core.Object {};
  (Object_Diagnosticable$36.new = function() {
  }).prototype = Object_Diagnosticable$36.prototype;
  dart.applyMixin(Object_Diagnosticable$36, diagnostics.Diagnosticable);
  sliver$.SliverGeometry = class SliverGeometry extends Object_Diagnosticable$36 {
    get scrollExtent() {
      return this[scrollExtent$];
    }
    set scrollExtent(value) {
      super.scrollExtent = value;
    }
    get paintOrigin() {
      return this[paintOrigin$];
    }
    set paintOrigin(value) {
      super.paintOrigin = value;
    }
    get paintExtent() {
      return this[paintExtent$];
    }
    set paintExtent(value) {
      super.paintExtent = value;
    }
    get layoutExtent() {
      return this[layoutExtent$];
    }
    set layoutExtent(value) {
      super.layoutExtent = value;
    }
    get maxPaintExtent() {
      return this[maxPaintExtent$];
    }
    set maxPaintExtent(value) {
      super.maxPaintExtent = value;
    }
    get maxScrollObstructionExtent() {
      return this[maxScrollObstructionExtent$];
    }
    set maxScrollObstructionExtent(value) {
      super.maxScrollObstructionExtent = value;
    }
    get hitTestExtent() {
      return this[hitTestExtent$];
    }
    set hitTestExtent(value) {
      super.hitTestExtent = value;
    }
    get visible() {
      return this[visible$];
    }
    set visible(value) {
      super.visible = value;
    }
    get hasVisualOverflow() {
      return this[hasVisualOverflow$];
    }
    set hasVisualOverflow(value) {
      super.hasVisualOverflow = value;
    }
    get scrollOffsetCorrection() {
      return this[scrollOffsetCorrection$];
    }
    set scrollOffsetCorrection(value) {
      super.scrollOffsetCorrection = value;
    }
    get cacheExtent() {
      return this[cacheExtent$];
    }
    set cacheExtent(value) {
      super.cacheExtent = value;
    }
    debugAssertIsValid(opts) {
      let informationCollector = opts && 'informationCollector' in opts ? opts.informationCollector : null;
      if (!dart.test(dart.fn(() => {
        let t7;
        const verify = (check, summary, opts) => {
          let details = opts && 'details' in opts ? opts.details : null;
          if (dart.test(check)) return;
          dart.throw(new assertions.FlutterError.fromParts((() => {
            let t3 = JSArrayOfDiagnosticsNodeL().of([]);
            t3[$add](new assertions.ErrorSummary.new(dart.str(object$.objectRuntimeType(this, "SliverGeometry")) + " is not valid: " + dart.str(summary)));
            let t4 = details;
            if (t4 != null) for (let t5 of t4)
              t3[$add](t5);
            if (informationCollector != null) for (let t6 of informationCollector())
              t3[$add](t6);
            return t3;
          })()));
        };
        dart.fn(verify, boolLAndStringL__Tovoid());
        verify(this.scrollExtent != null, "The \"scrollExtent\" is null.");
        verify(dart.notNull(this.scrollExtent) >= 0.0, "The \"scrollExtent\" is negative.");
        verify(this.paintExtent != null, "The \"paintExtent\" is null.");
        verify(dart.notNull(this.paintExtent) >= 0.0, "The \"paintExtent\" is negative.");
        verify(this.paintOrigin != null, "The \"paintOrigin\" is null.");
        verify(this.layoutExtent != null, "The \"layoutExtent\" is null.");
        verify(dart.notNull(this.layoutExtent) >= 0.0, "The \"layoutExtent\" is negative.");
        verify(dart.notNull(this.cacheExtent) >= 0.0, "The \"cacheExtent\" is negative.");
        if (dart.notNull(this.layoutExtent) > dart.notNull(this.paintExtent)) {
          verify(false, "The \"layoutExtent\" exceeds the \"paintExtent\".", {details: sliver$._debugCompareFloats("paintExtent", this.paintExtent, "layoutExtent", this.layoutExtent)});
        }
        verify(this.maxPaintExtent != null, "The \"maxPaintExtent\" is null.");
        if (dart.notNull(this.paintExtent) - dart.notNull(this.maxPaintExtent) > 1e-10) {
          verify(false, "The \"maxPaintExtent\" is less than the \"paintExtent\".", {details: (t7 = sliver$._debugCompareFloats("maxPaintExtent", this.maxPaintExtent, "paintExtent", this.paintExtent), (() => {
              t7[$add](new assertions.ErrorDescription.new("By definition, a sliver can't paint more than the maximum that it can paint!"));
              return t7;
            })())});
        }
        verify(this.hitTestExtent != null, "The \"hitTestExtent\" is null.");
        verify(dart.notNull(this.hitTestExtent) >= 0.0, "The \"hitTestExtent\" is negative.");
        verify(this.visible != null, "The \"visible\" property is null.");
        verify(this.hasVisualOverflow != null, "The \"hasVisualOverflow\" is null.");
        verify(this.scrollOffsetCorrection !== 0.0, "The \"scrollOffsetCorrection\" is zero.");
        return true;
      }, VoidToboolL())())) dart.assertFailed(null, L1, 716, 12, "() {\r\n      void verify(bool check, String summary, {List<DiagnosticsNode> details}) {\r\n        if (check)\r\n          return;\r\n        throw FlutterError.fromParts(<DiagnosticsNode>[\r\n          ErrorSummary('${objectRuntimeType(this, 'SliverGeometry')} is not valid: $summary'),\r\n          ...?details,\r\n          if (informationCollector != null)\r\n            ...informationCollector(),\r\n        ]);\r\n      }\r\n\r\n      verify(scrollExtent != null, 'The \"scrollExtent\" is null.');\r\n      verify(scrollExtent >= 0.0, 'The \"scrollExtent\" is negative.');\r\n      verify(paintExtent != null, 'The \"paintExtent\" is null.');\r\n      verify(paintExtent >= 0.0, 'The \"paintExtent\" is negative.');\r\n      verify(paintOrigin != null, 'The \"paintOrigin\" is null.');\r\n      verify(layoutExtent != null, 'The \"layoutExtent\" is null.');\r\n      verify(layoutExtent >= 0.0, 'The \"layoutExtent\" is negative.');\r\n      verify(cacheExtent >= 0.0, 'The \"cacheExtent\" is negative.');\r\n      if (layoutExtent > paintExtent) {\r\n        verify(false,\r\n          'The \"layoutExtent\" exceeds the \"paintExtent\".',\r\n          details: _debugCompareFloats('paintExtent', paintExtent, 'layoutExtent', layoutExtent),\r\n        );\r\n      }\r\n      verify(maxPaintExtent != null, 'The \"maxPaintExtent\" is null.');\r\n      // If the paintExtent is slightly more than the maxPaintExtent, but the difference is still less\r\n      // than precisionErrorTolerance, we will not throw the assert below.\r\n      if (paintExtent - maxPaintExtent > precisionErrorTolerance) {\r\n        verify(false,\r\n          'The \"maxPaintExtent\" is less than the \"paintExtent\".',\r\n          details:\r\n            _debugCompareFloats('maxPaintExtent', maxPaintExtent, 'paintExtent', paintExtent)\r\n              ..add(ErrorDescription(\"By definition, a sliver can't paint more than the maximum that it can paint!\")),\r\n        );\r\n      }\r\n      verify(hitTestExtent != null, 'The \"hitTestExtent\" is null.');\r\n      verify(hitTestExtent >= 0.0, 'The \"hitTestExtent\" is negative.');\r\n      verify(visible != null, 'The \"visible\" property is null.');\r\n      verify(hasVisualOverflow != null, 'The \"hasVisualOverflow\" is null.');\r\n      verify(scrollOffsetCorrection != 0.0, 'The \"scrollOffsetCorrection\" is zero.');\r\n      return true;\r\n    }()");
      return true;
    }
    toStringShort() {
      return object$.objectRuntimeType(this, "SliverGeometry");
    }
    debugFillProperties(properties) {
      super.debugFillProperties(properties);
      properties.add(new diagnostics.DoubleProperty.new("scrollExtent", this.scrollExtent));
      if (dart.notNull(this.paintExtent) > 0.0) {
        properties.add(new diagnostics.DoubleProperty.new("paintExtent", this.paintExtent, {unit: dart.test(this.visible) ? null : " but not painting"}));
      } else if (this.paintExtent === 0.0) {
        if (dart.test(this.visible)) {
          properties.add(new diagnostics.DoubleProperty.new("paintExtent", this.paintExtent, {unit: dart.test(this.visible) ? null : " but visible"}));
        }
        properties.add(new diagnostics.FlagProperty.new("visible", {value: this.visible, ifFalse: "hidden"}));
      } else {
        properties.add(new diagnostics.DoubleProperty.new("paintExtent", this.paintExtent, {tooltip: "!"}));
      }
      properties.add(new diagnostics.DoubleProperty.new("paintOrigin", this.paintOrigin, {defaultValue: 0.0}));
      properties.add(new diagnostics.DoubleProperty.new("layoutExtent", this.layoutExtent, {defaultValue: this.paintExtent}));
      properties.add(new diagnostics.DoubleProperty.new("maxPaintExtent", this.maxPaintExtent));
      properties.add(new diagnostics.DoubleProperty.new("hitTestExtent", this.hitTestExtent, {defaultValue: this.paintExtent}));
      properties.add(new (DiagnosticsPropertyOfboolL()).new("hasVisualOverflow", this.hasVisualOverflow, {defaultValue: false}));
      properties.add(new diagnostics.DoubleProperty.new("scrollOffsetCorrection", this.scrollOffsetCorrection, {defaultValue: null}));
      properties.add(new diagnostics.DoubleProperty.new("cacheExtent", this.cacheExtent, {defaultValue: 0.0}));
    }
  };
  (sliver$.SliverGeometry.new = function(opts) {
    let t3, t3$, t3$0, t3$1, t3$2;
    let scrollExtent = opts && 'scrollExtent' in opts ? opts.scrollExtent : 0;
    let paintExtent = opts && 'paintExtent' in opts ? opts.paintExtent : 0;
    let paintOrigin = opts && 'paintOrigin' in opts ? opts.paintOrigin : 0;
    let layoutExtent = opts && 'layoutExtent' in opts ? opts.layoutExtent : null;
    let maxPaintExtent = opts && 'maxPaintExtent' in opts ? opts.maxPaintExtent : 0;
    let maxScrollObstructionExtent = opts && 'maxScrollObstructionExtent' in opts ? opts.maxScrollObstructionExtent : 0;
    let hitTestExtent = opts && 'hitTestExtent' in opts ? opts.hitTestExtent : null;
    let visible = opts && 'visible' in opts ? opts.visible : null;
    let hasVisualOverflow = opts && 'hasVisualOverflow' in opts ? opts.hasVisualOverflow : false;
    let scrollOffsetCorrection = opts && 'scrollOffsetCorrection' in opts ? opts.scrollOffsetCorrection : null;
    let cacheExtent = opts && 'cacheExtent' in opts ? opts.cacheExtent : null;
    this[scrollExtent$] = scrollExtent;
    this[paintExtent$] = paintExtent;
    this[paintOrigin$] = paintOrigin;
    this[maxPaintExtent$] = maxPaintExtent;
    this[maxScrollObstructionExtent$] = maxScrollObstructionExtent;
    this[hasVisualOverflow$] = hasVisualOverflow;
    this[scrollOffsetCorrection$] = scrollOffsetCorrection;
    if (!(scrollExtent != null)) dart.assertFailed(null, L1, 551, 15, "scrollExtent != null");
    if (!(paintExtent != null)) dart.assertFailed(null, L1, 552, 15, "paintExtent != null");
    if (!(paintOrigin != null)) dart.assertFailed(null, L1, 553, 15, "paintOrigin != null");
    if (!(maxPaintExtent != null)) dart.assertFailed(null, L1, 554, 15, "maxPaintExtent != null");
    if (!(hasVisualOverflow != null)) dart.assertFailed(null, L1, 555, 15, "hasVisualOverflow != null");
    if (!(scrollOffsetCorrection !== 0.0)) dart.assertFailed(null, L1, 556, 15, "scrollOffsetCorrection != 0.0");
    this[layoutExtent$] = (t3 = layoutExtent, t3 == null ? paintExtent : t3);
    this[hitTestExtent$] = (t3$ = hitTestExtent, t3$ == null ? paintExtent : t3$);
    this[cacheExtent$] = (t3$1 = (t3$0 = cacheExtent, t3$0 == null ? layoutExtent : t3$0), t3$1 == null ? paintExtent : t3$1);
    this[visible$] = (t3$2 = visible, t3$2 == null ? dart.notNull(paintExtent) > 0.0 : t3$2);
    ;
  }).prototype = sliver$.SliverGeometry.prototype;
  dart.addTypeTests(sliver$.SliverGeometry);
  dart.addTypeCaches(sliver$.SliverGeometry);
  dart.setMethodSignature(sliver$.SliverGeometry, () => ({
    __proto__: dart.getMethods(sliver$.SliverGeometry.__proto__),
    debugAssertIsValid: dart.fnType(dart.legacy(core.bool), [], {informationCollector: dart.legacy(dart.fnType(core.Iterable$(diagnostics.DiagnosticsNode), []))}, {}),
    toStringShort: dart.fnType(dart.legacy(core.String), []),
    debugFillProperties: dart.fnType(dart.void, [dart.legacy(diagnostics.DiagnosticPropertiesBuilder)])
  }));
  dart.setLibraryUri(sliver$.SliverGeometry, L0);
  dart.setFieldSignature(sliver$.SliverGeometry, () => ({
    __proto__: dart.getFields(sliver$.SliverGeometry.__proto__),
    scrollExtent: dart.finalFieldType(dart.legacy(core.double)),
    paintOrigin: dart.finalFieldType(dart.legacy(core.double)),
    paintExtent: dart.finalFieldType(dart.legacy(core.double)),
    layoutExtent: dart.finalFieldType(dart.legacy(core.double)),
    maxPaintExtent: dart.finalFieldType(dart.legacy(core.double)),
    maxScrollObstructionExtent: dart.finalFieldType(dart.legacy(core.double)),
    hitTestExtent: dart.finalFieldType(dart.legacy(core.double)),
    visible: dart.finalFieldType(dart.legacy(core.bool)),
    hasVisualOverflow: dart.finalFieldType(dart.legacy(core.bool)),
    scrollOffsetCorrection: dart.finalFieldType(dart.legacy(core.double)),
    cacheExtent: dart.finalFieldType(dart.legacy(core.double))
  }));
  dart.defineLazy(sliver$.SliverGeometry, {
    /*sliver$.SliverGeometry.zero*/get zero() {
      return C9 || CT.C9;
    }
  }, true);
  sliver$.SliverHitTestResult = class SliverHitTestResult extends hit_test.HitTestResult {
    addWithAxisOffset(opts) {
      let paintOffset = opts && 'paintOffset' in opts ? opts.paintOffset : null;
      let mainAxisOffset = opts && 'mainAxisOffset' in opts ? opts.mainAxisOffset : null;
      let crossAxisOffset = opts && 'crossAxisOffset' in opts ? opts.crossAxisOffset : null;
      let mainAxisPosition = opts && 'mainAxisPosition' in opts ? opts.mainAxisPosition : null;
      let crossAxisPosition = opts && 'crossAxisPosition' in opts ? opts.crossAxisPosition : null;
      let hitTest = opts && 'hitTest' in opts ? opts.hitTest : null;
      if (!(mainAxisOffset != null)) dart.assertFailed(null, L1, 858, 12, "mainAxisOffset != null");
      if (!(crossAxisOffset != null)) dart.assertFailed(null, L1, 859, 12, "crossAxisOffset != null");
      if (!(mainAxisPosition != null)) dart.assertFailed(null, L1, 860, 12, "mainAxisPosition != null");
      if (!(crossAxisPosition != null)) dart.assertFailed(null, L1, 861, 12, "crossAxisPosition != null");
      if (!(hitTest != null)) dart.assertFailed(null, L1, 862, 12, "hitTest != null");
      if (paintOffset != null) {
        this.pushOffset(paintOffset._negate());
      }
      let isHit = hitTest(this, {mainAxisPosition: dart.notNull(mainAxisPosition) - dart.notNull(mainAxisOffset), crossAxisPosition: dart.notNull(crossAxisPosition) - dart.notNull(crossAxisOffset)});
      if (paintOffset != null) {
        this.popTransform();
      }
      return isHit;
    }
  };
  (sliver$.SliverHitTestResult.new = function() {
    sliver$.SliverHitTestResult.__proto__.new.call(this);
    ;
  }).prototype = sliver$.SliverHitTestResult.prototype;
  (sliver$.SliverHitTestResult.wrap = function(result) {
    sliver$.SliverHitTestResult.__proto__.wrap.call(this, result);
    ;
  }).prototype = sliver$.SliverHitTestResult.prototype;
  dart.addTypeTests(sliver$.SliverHitTestResult);
  dart.addTypeCaches(sliver$.SliverHitTestResult);
  dart.setMethodSignature(sliver$.SliverHitTestResult, () => ({
    __proto__: dart.getMethods(sliver$.SliverHitTestResult.__proto__),
    addWithAxisOffset: dart.fnType(dart.legacy(core.bool), [], {crossAxisOffset: dart.legacy(core.double), crossAxisPosition: dart.legacy(core.double), hitTest: dart.legacy(dart.fnType(dart.legacy(core.bool), [dart.legacy(sliver$.SliverHitTestResult)], {crossAxisPosition: dart.legacy(core.double), mainAxisPosition: dart.legacy(core.double)}, {})), mainAxisOffset: dart.legacy(core.double), mainAxisPosition: dart.legacy(core.double), paintOffset: dart.legacy(ui.Offset)}, {})
  }));
  dart.setLibraryUri(sliver$.SliverHitTestResult, L0);
  var mainAxisPosition$ = dart.privateName(sliver$, "SliverHitTestEntry.mainAxisPosition");
  var crossAxisPosition$ = dart.privateName(sliver$, "SliverHitTestEntry.crossAxisPosition");
  sliver$.SliverHitTestEntry = class SliverHitTestEntry extends hit_test.HitTestEntry {
    get mainAxisPosition() {
      return this[mainAxisPosition$];
    }
    set mainAxisPosition(value) {
      super.mainAxisPosition = value;
    }
    get crossAxisPosition() {
      return this[crossAxisPosition$];
    }
    set crossAxisPosition(value) {
      super.crossAxisPosition = value;
    }
    get target() {
      return RenderSliverL().as(super.target);
    }
    toString() {
      return dart.str(dart.runtimeType(this.target)) + "@(mainAxis: " + dart.str(this.mainAxisPosition) + ", crossAxis: " + dart.str(this.crossAxisPosition) + ")";
    }
  };
  (sliver$.SliverHitTestEntry.new = function(target, opts) {
    let mainAxisPosition = opts && 'mainAxisPosition' in opts ? opts.mainAxisPosition : null;
    let crossAxisPosition = opts && 'crossAxisPosition' in opts ? opts.crossAxisPosition : null;
    this[mainAxisPosition$] = mainAxisPosition;
    this[crossAxisPosition$] = crossAxisPosition;
    if (!(mainAxisPosition != null)) dart.assertFailed(null, L1, 890, 15, "mainAxisPosition != null");
    if (!(crossAxisPosition != null)) dart.assertFailed(null, L1, 891, 15, "crossAxisPosition != null");
    sliver$.SliverHitTestEntry.__proto__.new.call(this, target);
    ;
  }).prototype = sliver$.SliverHitTestEntry.prototype;
  dart.addTypeTests(sliver$.SliverHitTestEntry);
  dart.addTypeCaches(sliver$.SliverHitTestEntry);
  dart.setGetterSignature(sliver$.SliverHitTestEntry, () => ({
    __proto__: dart.getGetters(sliver$.SliverHitTestEntry.__proto__),
    target: dart.legacy(sliver$.RenderSliver)
  }));
  dart.setLibraryUri(sliver$.SliverHitTestEntry, L0);
  dart.setFieldSignature(sliver$.SliverHitTestEntry, () => ({
    __proto__: dart.getFields(sliver$.SliverHitTestEntry.__proto__),
    mainAxisPosition: dart.finalFieldType(dart.legacy(core.double)),
    crossAxisPosition: dart.finalFieldType(dart.legacy(core.double))
  }));
  dart.defineExtensionMethods(sliver$.SliverHitTestEntry, ['toString']);
  var layoutOffset = dart.privateName(sliver$, "SliverLogicalParentData.layoutOffset");
  sliver$.SliverLogicalParentData = class SliverLogicalParentData extends object.ParentData {
    get layoutOffset() {
      return this[layoutOffset];
    }
    set layoutOffset(value) {
      this[layoutOffset] = value;
    }
    toString() {
      return "layoutOffset=" + (this.layoutOffset == null ? "None" : this.layoutOffset[$toStringAsFixed](1));
    }
  };
  (sliver$.SliverLogicalParentData.new = function() {
    this[layoutOffset] = null;
    ;
  }).prototype = sliver$.SliverLogicalParentData.prototype;
  dart.addTypeTests(sliver$.SliverLogicalParentData);
  dart.addTypeCaches(sliver$.SliverLogicalParentData);
  dart.setLibraryUri(sliver$.SliverLogicalParentData, L0);
  dart.setFieldSignature(sliver$.SliverLogicalParentData, () => ({
    __proto__: dart.getFields(sliver$.SliverLogicalParentData.__proto__),
    layoutOffset: dart.fieldType(dart.legacy(core.double))
  }));
  dart.defineExtensionMethods(sliver$.SliverLogicalParentData, ['toString']);
  var _geometry = dart.privateName(sliver$, "_geometry");
  var _debugDrawArrow = dart.privateName(sliver$, "_debugDrawArrow");
  var Color_value = dart.privateName(ui, "Color.value");
  var C10;
  sliver$.RenderSliver = class RenderSliver extends object.RenderObject {
    get constraints() {
      return SliverConstraintsL().as(super.constraints);
    }
    get geometry() {
      return this[_geometry];
    }
    set geometry(value) {
      if (!!(dart.test(this.debugDoingThisResize) && dart.test(this.debugDoingThisLayout))) dart.assertFailed(null, L1, 1153, 12, "!(debugDoingThisResize && debugDoingThisLayout)");
      if (!(dart.test(this.sizedByParent) || !dart.test(this.debugDoingThisResize))) dart.assertFailed(null, L1, 1154, 12, "sizedByParent || !debugDoingThisResize");
      if (!dart.test(dart.fn(() => {
        if (dart.test(this.sizedByParent) && dart.test(this.debugDoingThisResize) || !dart.test(this.sizedByParent) && dart.test(this.debugDoingThisLayout)) return true;
        if (!!dart.test(this.debugDoingThisResize)) dart.assertFailed(null, L1, 1159, 14, "!debugDoingThisResize");
        let contract = null;
        let violation = null;
        let hint = null;
        if (dart.test(this.debugDoingThisLayout)) {
          if (!dart.test(this.sizedByParent)) dart.assertFailed(null, L1, 1162, 16, "sizedByParent");
          violation = new assertions.ErrorDescription.new("It appears that the geometry setter was called from performLayout().");
        } else {
          violation = new assertions.ErrorDescription.new("The geometry setter was called from outside layout (neither performResize() nor performLayout() were being run for this object).");
          if (this.owner != null && dart.test(this.owner.debugDoingLayout)) hint = new assertions.ErrorDescription.new("Only the object itself can set its geometry. It is a contract violation for other objects to set it.");
        }
        if (dart.test(this.sizedByParent))
          contract = new assertions.ErrorDescription.new("Because this RenderSliver has sizedByParent set to true, it must set its geometry in performResize().");
        else
          contract = new assertions.ErrorDescription.new("Because this RenderSliver has sizedByParent set to false, it must set its geometry in performLayout().");
        let information = (() => {
          let t7 = JSArrayOfDiagnosticsNodeL().of([]);
          t7[$add](new assertions.ErrorSummary.new("RenderSliver geometry setter called incorrectly."));
          t7[$add](violation);
          if (hint != null) t7[$add](hint);
          t7[$add](contract);
          t7[$add](this.describeForError("The RenderSliver in question is"));
          return t7;
        })();
        dart.throw(new assertions.FlutterError.fromParts(information));
      }, VoidToboolL())())) dart.assertFailed(null, L1, 1155, 12, "() {\r\n      if ((sizedByParent && debugDoingThisResize) ||\r\n          (!sizedByParent && debugDoingThisLayout))\r\n        return true;\r\n      assert(!debugDoingThisResize);\r\n      DiagnosticsNode contract, violation, hint;\r\n      if (debugDoingThisLayout) {\r\n        assert(sizedByParent);\r\n        violation = ErrorDescription('It appears that the geometry setter was called from performLayout().');\r\n      } else {\r\n        violation = ErrorDescription('The geometry setter was called from outside layout (neither performResize() nor performLayout() were being run for this object).');\r\n        if (owner != null && owner.debugDoingLayout)\r\n          hint = ErrorDescription('Only the object itself can set its geometry. It is a contract violation for other objects to set it.');\r\n      }\r\n      if (sizedByParent)\r\n        contract = ErrorDescription('Because this RenderSliver has sizedByParent set to true, it must set its geometry in performResize().');\r\n      else\r\n        contract = ErrorDescription('Because this RenderSliver has sizedByParent set to false, it must set its geometry in performLayout().');\r\n\r\n      final List<DiagnosticsNode> information = <DiagnosticsNode>[\r\n        ErrorSummary('RenderSliver geometry setter called incorrectly.'),\r\n        violation,\r\n        if (hint != null) hint,\r\n        contract,\r\n        describeForError('The RenderSliver in question is'),\r\n      ];\r\n      throw FlutterError.fromParts(information);\r\n    }()");
      this[_geometry] = value;
    }
    get semanticBounds() {
      return this.paintBounds;
    }
    get paintBounds() {
      if (!(this.constraints.axis != null)) dart.assertFailed(null, L1, 1191, 12, "constraints.axis != null");
      switch (this.constraints.axis) {
        case C7 || CT.C7:
        {
          return new ui.Rect.fromLTWH(0.0, 0.0, this.geometry.paintExtent, this.constraints.crossAxisExtent);
        }
        case C8 || CT.C8:
        {
          return new ui.Rect.fromLTWH(0.0, 0.0, this.constraints.crossAxisExtent, this.geometry.paintExtent);
        }
      }
      return null;
    }
    debugResetSize() {
    }
    debugAssertDoesMeetConstraints() {
      if (!dart.test(this.geometry.debugAssertIsValid({informationCollector: dart.fn(() => new (SyncIterableOfDiagnosticsNodeL()).new((function*() {
          yield this.describeForError("The RenderSliver that returned the offending geometry was");
        }).bind(this)), VoidToIterableLOfDiagnosticsNodeL())}))) dart.assertFailed(null, L1, 1214, 12, "geometry.debugAssertIsValid(\r\n      informationCollector: () sync* {\r\n        yield describeForError('The RenderSliver that returned the offending geometry was');\r\n      }\r\n    )");
      if (!dart.test(dart.fn(() => {
        if (dart.notNull(this.geometry.paintOrigin) + dart.notNull(this.geometry.paintExtent) > dart.notNull(this.constraints.remainingPaintExtent)) {
          dart.throw(new assertions.FlutterError.fromParts((() => {
            let t8 = JSArrayOfDiagnosticsNodeL().of([]);
            t8[$add](new assertions.ErrorSummary.new("SliverGeometry has a paintOffset that exceeds the remainingPaintExtent from the constraints."));
            t8[$add](this.describeForError("The render object whose geometry violates the constraints is the following"));
            for (let t9 of sliver$._debugCompareFloats("remainingPaintExtent", this.constraints.remainingPaintExtent, "paintOrigin + paintExtent", dart.notNull(this.geometry.paintOrigin) + dart.notNull(this.geometry.paintExtent)))
              t8[$add](t9);
            t8[$add](new assertions.ErrorDescription.new("The paintOrigin and paintExtent must cause the child sliver to paint " + "within the viewport, and so cannot exceed the remainingPaintExtent."));
            return t8;
          })()));
        }
        return true;
      }, VoidToboolL())())) dart.assertFailed(null, L1, 1219, 12, "() {\r\n      if (geometry.paintOrigin + geometry.paintExtent > constraints.remainingPaintExtent) {\r\n        throw FlutterError.fromParts(<DiagnosticsNode>[\r\n          ErrorSummary('SliverGeometry has a paintOffset that exceeds the remainingPaintExtent from the constraints.'),\r\n          describeForError('The render object whose geometry violates the constraints is the following'),\r\n          ..._debugCompareFloats(\r\n            'remainingPaintExtent', constraints.remainingPaintExtent,\r\n            'paintOrigin + paintExtent', geometry.paintOrigin + geometry.paintExtent,\r\n          ),\r\n          ErrorDescription(\r\n            'The paintOrigin and paintExtent must cause the child sliver to paint '\r\n            'within the viewport, and so cannot exceed the remainingPaintExtent.',\r\n          ),\r\n        ]);\r\n      }\r\n      return true;\r\n    }()");
    }
    performResize() {
      if (!false) dart.assertFailed(null, L1, 1240, 12, "false");
    }
    get centerOffsetAdjustment() {
      return 0.0;
    }
    hitTest(result, opts) {
      let mainAxisPosition = opts && 'mainAxisPosition' in opts ? opts.mainAxisPosition : null;
      let crossAxisPosition = opts && 'crossAxisPosition' in opts ? opts.crossAxisPosition : null;
      if (dart.notNull(mainAxisPosition) >= 0.0 && dart.notNull(mainAxisPosition) < dart.notNull(this.geometry.hitTestExtent) && dart.notNull(crossAxisPosition) >= 0.0 && dart.notNull(crossAxisPosition) < dart.notNull(this.constraints.crossAxisExtent)) {
        if (dart.test(this.hitTestChildren(result, {mainAxisPosition: mainAxisPosition, crossAxisPosition: crossAxisPosition})) || dart.test(this.hitTestSelf({mainAxisPosition: mainAxisPosition, crossAxisPosition: crossAxisPosition}))) {
          result.add(new sliver$.SliverHitTestEntry.new(this, {mainAxisPosition: mainAxisPosition, crossAxisPosition: crossAxisPosition}));
          return true;
        }
      }
      return false;
    }
    hitTestSelf(opts) {
      let mainAxisPosition = opts && 'mainAxisPosition' in opts ? opts.mainAxisPosition : null;
      let crossAxisPosition = opts && 'crossAxisPosition' in opts ? opts.crossAxisPosition : null;
      return false;
    }
    hitTestChildren(result, opts) {
      let mainAxisPosition = opts && 'mainAxisPosition' in opts ? opts.mainAxisPosition : null;
      let crossAxisPosition = opts && 'crossAxisPosition' in opts ? opts.crossAxisPosition : null;
      return false;
    }
    calculatePaintOffset(constraints, opts) {
      let from = opts && 'from' in opts ? opts.from : null;
      let to = opts && 'to' in opts ? opts.to : null;
      if (!(dart.notNull(from) <= dart.notNull(to))) dart.assertFailed(null, L1, 1351, 12, "from <= to");
      let a = constraints.scrollOffset;
      let b = dart.notNull(constraints.scrollOffset) + dart.notNull(constraints.remainingPaintExtent);
      return (to[$clamp](a, b) - from[$clamp](a, b))[$clamp](0.0, constraints.remainingPaintExtent);
    }
    calculateCacheOffset(constraints, opts) {
      let from = opts && 'from' in opts ? opts.from : null;
      let to = opts && 'to' in opts ? opts.to : null;
      if (!(dart.notNull(from) <= dart.notNull(to))) dart.assertFailed(null, L1, 1367, 12, "from <= to");
      let a = dart.notNull(constraints.scrollOffset) + dart.notNull(constraints.cacheOrigin);
      let b = dart.notNull(constraints.scrollOffset) + dart.notNull(constraints.remainingCacheExtent);
      return (to[$clamp](a, b) - from[$clamp](a, b))[$clamp](0.0, constraints.remainingCacheExtent);
    }
    childMainAxisPosition(child) {
      RenderObjectL().as(child);
      if (!dart.dtest(dart.fn(() => {
        dart.throw(assertions.FlutterError.new(dart.str(object$.objectRuntimeType(this, "RenderSliver")) + " does not implement childPosition."));
      }, VoidToNullN())())) dart.assertFailed(null, L1, 1402, 12, "() {\r\n      throw FlutterError('${objectRuntimeType(this, 'RenderSliver')} does not implement childPosition.');\r\n    }()");
      return 0.0;
    }
    childCrossAxisPosition(child) {
      RenderObjectL().as(child);
      return 0.0;
    }
    childScrollOffset(child) {
      RenderObjectL().as(child);
      if (!dart.equals(child.parent, this)) dart.assertFailed(null, L1, 1433, 12, "child.parent == this");
      return 0.0;
    }
    applyPaintTransform(child, transform) {
      RenderObjectL().as(child);
      if (!dart.dtest(dart.fn(() => {
        dart.throw(assertions.FlutterError.new(dart.str(object$.objectRuntimeType(this, "RenderSliver")) + " does not implement applyPaintTransform."));
      }, VoidToNullN())())) dart.assertFailed(null, L1, 1439, 12, "() {\r\n      throw FlutterError('${objectRuntimeType(this, 'RenderSliver')} does not implement applyPaintTransform.');\r\n    }()");
    }
    getAbsoluteSizeRelativeToOrigin() {
      if (!(this.geometry != null)) dart.assertFailed(null, L1, 1455, 12, "geometry != null");
      if (!!dart.test(this.debugNeedsLayout)) dart.assertFailed(null, L1, 1456, 12, "!debugNeedsLayout");
      switch (sliver$.applyGrowthDirectionToAxisDirection(this.constraints.axisDirection, this.constraints.growthDirection)) {
        case C5 || CT.C5:
        {
          return new ui.Size.new(this.constraints.crossAxisExtent, -dart.notNull(this.geometry.paintExtent));
        }
        case C4 || CT.C4:
        {
          return new ui.Size.new(this.geometry.paintExtent, this.constraints.crossAxisExtent);
        }
        case C3 || CT.C3:
        {
          return new ui.Size.new(this.constraints.crossAxisExtent, this.geometry.paintExtent);
        }
        case C6 || CT.C6:
        {
          return new ui.Size.new(-dart.notNull(this.geometry.paintExtent), this.constraints.crossAxisExtent);
        }
      }
      return null;
    }
    getAbsoluteSize() {
      if (!(this.geometry != null)) dart.assertFailed(null, L1, 1481, 12, "geometry != null");
      if (!!dart.test(this.debugNeedsLayout)) dart.assertFailed(null, L1, 1482, 12, "!debugNeedsLayout");
      switch (this.constraints.axisDirection) {
        case C5 || CT.C5:
        case C3 || CT.C3:
        {
          return new ui.Size.new(this.constraints.crossAxisExtent, this.geometry.paintExtent);
        }
        case C4 || CT.C4:
        case C6 || CT.C6:
        {
          return new ui.Size.new(this.geometry.paintExtent, this.constraints.crossAxisExtent);
        }
      }
      return null;
    }
    [_debugDrawArrow](canvas, paint, p0, p1, direction) {
      if (!dart.test(dart.fn(() => {
        let t10;
        if (dart.equals(p0, p1)) return true;
        if (!(p0.dx == p1.dx || p0.dy == p1.dy)) dart.assertFailed(null, L1, 1498, 14, "p0.dx == p1.dx || p0.dy == p1.dy");
        let d = dart.notNull(p1['-'](p0).distance) * 0.2;
        let temp = null;
        let dx1 = null;
        let dx2 = null;
        let dy1 = null;
        let dy2 = null;
        switch (direction) {
          case C0 || CT.C0:
          {
            dx1 = dx2 = dy1 = dy2 = d;
            break;
          }
          case C1 || CT.C1:
          {
            temp = p0;
            p0 = p1;
            p1 = temp;
            dx1 = dx2 = dy1 = dy2 = -d;
            break;
          }
        }
        if (p0.dx == p1.dx) {
          dx2 = -dart.notNull(dx2);
        } else {
          dy2 = -dart.notNull(dy2);
        }
        canvas.drawPath((t10 = ui.Path.new(), (() => {
          t10.moveTo(p0.dx, p0.dy);
          t10.lineTo(p1.dx, p1.dy);
          t10.moveTo(dart.notNull(p1.dx) - dart.notNull(dx1), dart.notNull(p1.dy) - dart.notNull(dy1));
          t10.lineTo(p1.dx, p1.dy);
          t10.lineTo(dart.notNull(p1.dx) - dart.notNull(dx2), dart.notNull(p1.dy) - dart.notNull(dy2));
          return t10;
        })()), paint);
        return true;
      }, VoidToboolL())())) dart.assertFailed(null, L1, 1495, 12, "() {\r\n      if (p0 == p1)\r\n        return true;\r\n      assert(p0.dx == p1.dx || p0.dy == p1.dy); // must be axis-aligned\r\n      final double d = (p1 - p0).distance * 0.2;\r\n      Offset temp;\r\n      double dx1, dx2, dy1, dy2;\r\n      switch (direction) {\r\n        case GrowthDirection.forward:\r\n          dx1 = dx2 = dy1 = dy2 = d;\r\n          break;\r\n        case GrowthDirection.reverse:\r\n          temp = p0;\r\n          p0 = p1;\r\n          p1 = temp;\r\n          dx1 = dx2 = dy1 = dy2 = -d;\r\n          break;\r\n      }\r\n      if (p0.dx == p1.dx) {\r\n        dx2 = -dx2;\r\n      } else {\r\n        dy2 = -dy2;\r\n      }\r\n      canvas.drawPath(\r\n        Path()\r\n          ..moveTo(p0.dx, p0.dy)\r\n          ..lineTo(p1.dx, p1.dy)\r\n          ..moveTo(p1.dx - dx1, p1.dy - dy1)\r\n          ..lineTo(p1.dx, p1.dy)\r\n          ..lineTo(p1.dx - dx2, p1.dy - dy2),\r\n        paint,\r\n      );\r\n      return true;\r\n    }()");
    }
    debugPaint(context, offset) {
      if (!dart.test(dart.fn(() => {
        let t10;
        if (dart.test(debug.debugPaintSizeEnabled)) {
          let strokeWidth = math.min(doubleL(), 4.0, dart.notNull(this.geometry.paintExtent) / 30.0);
          let paint = (t10 = ui.Paint.new(), (() => {
            t10.color = C10 || CT.C10;
            t10.strokeWidth = strokeWidth;
            t10.style = ui.PaintingStyle.stroke;
            t10.maskFilter = new ui.MaskFilter.blur(ui.BlurStyle.solid, strokeWidth);
            return t10;
          })());
          let arrowExtent = this.geometry.paintExtent;
          let padding = math.max(doubleL(), 2.0, strokeWidth);
          let canvas = context.canvas;
          canvas.drawCircle(offset.translate(padding, padding), padding * 0.5, paint);
          switch (this.constraints.axis) {
            case C8 || CT.C8:
            {
              canvas.drawLine(offset, offset.translate(this.constraints.crossAxisExtent, 0.0), paint);
              this[_debugDrawArrow](canvas, paint, offset.translate(dart.notNull(this.constraints.crossAxisExtent) * 1.0 / 4.0, padding), offset.translate(dart.notNull(this.constraints.crossAxisExtent) * 1.0 / 4.0, dart.notNull(arrowExtent) - padding), this.constraints.normalizedGrowthDirection);
              this[_debugDrawArrow](canvas, paint, offset.translate(dart.notNull(this.constraints.crossAxisExtent) * 3.0 / 4.0, padding), offset.translate(dart.notNull(this.constraints.crossAxisExtent) * 3.0 / 4.0, dart.notNull(arrowExtent) - padding), this.constraints.normalizedGrowthDirection);
              break;
            }
            case C7 || CT.C7:
            {
              canvas.drawLine(offset, offset.translate(0.0, this.constraints.crossAxisExtent), paint);
              this[_debugDrawArrow](canvas, paint, offset.translate(padding, dart.notNull(this.constraints.crossAxisExtent) * 1.0 / 4.0), offset.translate(dart.notNull(arrowExtent) - padding, dart.notNull(this.constraints.crossAxisExtent) * 1.0 / 4.0), this.constraints.normalizedGrowthDirection);
              this[_debugDrawArrow](canvas, paint, offset.translate(padding, dart.notNull(this.constraints.crossAxisExtent) * 3.0 / 4.0), offset.translate(dart.notNull(arrowExtent) - padding, dart.notNull(this.constraints.crossAxisExtent) * 3.0 / 4.0), this.constraints.normalizedGrowthDirection);
              break;
            }
          }
        }
        return true;
      }, VoidToboolL())())) dart.assertFailed(null, L1, 1533, 12, "() {\r\n      if (debugPaintSizeEnabled) {\r\n        final double strokeWidth = math.min(4.0, geometry.paintExtent / 30.0);\r\n        final Paint paint = Paint()\r\n          ..color = const Color(0xFF33CC33)\r\n          ..strokeWidth = strokeWidth\r\n          ..style = PaintingStyle.stroke\r\n          ..maskFilter = MaskFilter.blur(BlurStyle.solid, strokeWidth);\r\n        final double arrowExtent = geometry.paintExtent;\r\n        final double padding = math.max(2.0, strokeWidth);\r\n        final Canvas canvas = context.canvas;\r\n        canvas.drawCircle(\r\n          offset.translate(padding, padding),\r\n          padding * 0.5,\r\n          paint,\r\n        );\r\n        switch (constraints.axis) {\r\n          case Axis.vertical:\r\n            canvas.drawLine(\r\n              offset,\r\n              offset.translate(constraints.crossAxisExtent, 0.0),\r\n              paint,\r\n            );\r\n            _debugDrawArrow(\r\n              canvas,\r\n              paint,\r\n              offset.translate(constraints.crossAxisExtent * 1.0 / 4.0, padding),\r\n              offset.translate(constraints.crossAxisExtent * 1.0 / 4.0, arrowExtent - padding),\r\n              constraints.normalizedGrowthDirection,\r\n            );\r\n            _debugDrawArrow(\r\n              canvas,\r\n              paint,\r\n              offset.translate(constraints.crossAxisExtent * 3.0 / 4.0, padding),\r\n              offset.translate(constraints.crossAxisExtent * 3.0 / 4.0, arrowExtent - padding),\r\n              constraints.normalizedGrowthDirection,\r\n            );\r\n            break;\r\n          case Axis.horizontal:\r\n            canvas.drawLine(\r\n              offset,\r\n              offset.translate(0.0, constraints.crossAxisExtent),\r\n              paint,\r\n            );\r\n            _debugDrawArrow(\r\n              canvas,\r\n              paint,\r\n              offset.translate(padding, constraints.crossAxisExtent * 1.0 / 4.0),\r\n              offset.translate(arrowExtent - padding, constraints.crossAxisExtent * 1.0 / 4.0),\r\n              constraints.normalizedGrowthDirection,\r\n            );\r\n            _debugDrawArrow(\r\n              canvas,\r\n              paint,\r\n              offset.translate(padding, constraints.crossAxisExtent * 3.0 / 4.0),\r\n              offset.translate(arrowExtent - padding, constraints.crossAxisExtent * 3.0 / 4.0),\r\n              constraints.normalizedGrowthDirection,\r\n            );\r\n            break;\r\n        }\r\n      }\r\n      return true;\r\n    }()");
    }
    handleEvent(event, entry) {
      SliverHitTestEntryL().as(entry);
    }
    debugFillProperties(properties) {
      super.debugFillProperties(properties);
      properties.add(new (DiagnosticsPropertyOfSliverGeometryL()).new("geometry", this.geometry));
    }
  };
  (sliver$.RenderSliver.new = function() {
    this[_geometry] = null;
    sliver$.RenderSliver.__proto__.new.call(this);
    ;
  }).prototype = sliver$.RenderSliver.prototype;
  dart.addTypeTests(sliver$.RenderSliver);
  dart.addTypeCaches(sliver$.RenderSliver);
  dart.setMethodSignature(sliver$.RenderSliver, () => ({
    __proto__: dart.getMethods(sliver$.RenderSliver.__proto__),
    debugAssertDoesMeetConstraints: dart.fnType(dart.void, []),
    performResize: dart.fnType(dart.void, []),
    hitTest: dart.fnType(dart.legacy(core.bool), [dart.legacy(sliver$.SliverHitTestResult)], {crossAxisPosition: dart.legacy(core.double), mainAxisPosition: dart.legacy(core.double)}, {}),
    hitTestSelf: dart.fnType(dart.legacy(core.bool), [], {crossAxisPosition: dart.legacy(core.double), mainAxisPosition: dart.legacy(core.double)}, {}),
    hitTestChildren: dart.fnType(dart.legacy(core.bool), [dart.legacy(sliver$.SliverHitTestResult)], {crossAxisPosition: dart.legacy(core.double), mainAxisPosition: dart.legacy(core.double)}, {}),
    calculatePaintOffset: dart.fnType(dart.legacy(core.double), [dart.legacy(sliver$.SliverConstraints)], {from: dart.legacy(core.double), to: dart.legacy(core.double)}, {}),
    calculateCacheOffset: dart.fnType(dart.legacy(core.double), [dart.legacy(sliver$.SliverConstraints)], {from: dart.legacy(core.double), to: dart.legacy(core.double)}, {}),
    childMainAxisPosition: dart.fnType(dart.legacy(core.double), [dart.legacy(core.Object)]),
    childCrossAxisPosition: dart.fnType(dart.legacy(core.double), [dart.legacy(core.Object)]),
    childScrollOffset: dart.fnType(dart.legacy(core.double), [dart.legacy(core.Object)]),
    getAbsoluteSizeRelativeToOrigin: dart.fnType(dart.legacy(ui.Size), []),
    getAbsoluteSize: dart.fnType(dart.legacy(ui.Size), []),
    [_debugDrawArrow]: dart.fnType(dart.void, [dart.legacy(ui.Canvas), dart.legacy(ui.Paint), dart.legacy(ui.Offset), dart.legacy(ui.Offset), dart.legacy(sliver$.GrowthDirection)])
  }));
  dart.setGetterSignature(sliver$.RenderSliver, () => ({
    __proto__: dart.getGetters(sliver$.RenderSliver.__proto__),
    constraints: dart.legacy(sliver$.SliverConstraints),
    geometry: dart.legacy(sliver$.SliverGeometry),
    semanticBounds: dart.legacy(ui.Rect),
    paintBounds: dart.legacy(ui.Rect),
    centerOffsetAdjustment: dart.legacy(core.double)
  }));
  dart.setSetterSignature(sliver$.RenderSliver, () => ({
    __proto__: dart.getSetters(sliver$.RenderSliver.__proto__),
    geometry: dart.legacy(sliver$.SliverGeometry)
  }));
  dart.setLibraryUri(sliver$.RenderSliver, L0);
  dart.setFieldSignature(sliver$.RenderSliver, () => ({
    __proto__: dart.getFields(sliver$.RenderSliver.__proto__),
    [_geometry]: dart.fieldType(dart.legacy(sliver$.SliverGeometry))
  }));
  const SliverLogicalParentData_ContainerParentDataMixin$36 = class SliverLogicalParentData_ContainerParentDataMixin extends sliver$.SliverLogicalParentData {};
  (SliverLogicalParentData_ContainerParentDataMixin$36.new = function() {
    object.ContainerParentDataMixin$(dart.legacy(sliver$.RenderSliver))[dart.mixinNew].call(this);
    SliverLogicalParentData_ContainerParentDataMixin$36.__proto__.new.call(this);
  }).prototype = SliverLogicalParentData_ContainerParentDataMixin$36.prototype;
  dart.applyMixin(SliverLogicalParentData_ContainerParentDataMixin$36, object.ContainerParentDataMixin$(dart.legacy(sliver$.RenderSliver)));
  sliver$.SliverLogicalContainerParentData = class SliverLogicalContainerParentData extends SliverLogicalParentData_ContainerParentDataMixin$36 {};
  (sliver$.SliverLogicalContainerParentData.new = function() {
    sliver$.SliverLogicalContainerParentData.__proto__.new.call(this);
    ;
  }).prototype = sliver$.SliverLogicalContainerParentData.prototype;
  dart.addTypeTests(sliver$.SliverLogicalContainerParentData);
  dart.addTypeCaches(sliver$.SliverLogicalContainerParentData);
  dart.setLibraryUri(sliver$.SliverLogicalContainerParentData, L0);
  var paintOffset = dart.privateName(sliver$, "SliverPhysicalParentData.paintOffset");
  sliver$.SliverPhysicalParentData = class SliverPhysicalParentData extends object.ParentData {
    get paintOffset() {
      return this[paintOffset];
    }
    set paintOffset(value) {
      this[paintOffset] = value;
    }
    applyPaintTransform(transform) {
      transform.translate(this.paintOffset.dx, this.paintOffset.dy);
    }
    toString() {
      return "paintOffset=" + dart.str(this.paintOffset);
    }
  };
  (sliver$.SliverPhysicalParentData.new = function() {
    this[paintOffset] = ui.Offset.zero;
    ;
  }).prototype = sliver$.SliverPhysicalParentData.prototype;
  dart.addTypeTests(sliver$.SliverPhysicalParentData);
  dart.addTypeCaches(sliver$.SliverPhysicalParentData);
  dart.setMethodSignature(sliver$.SliverPhysicalParentData, () => ({
    __proto__: dart.getMethods(sliver$.SliverPhysicalParentData.__proto__),
    applyPaintTransform: dart.fnType(dart.void, [dart.legacy(vector_math_64.Matrix4)])
  }));
  dart.setLibraryUri(sliver$.SliverPhysicalParentData, L0);
  dart.setFieldSignature(sliver$.SliverPhysicalParentData, () => ({
    __proto__: dart.getFields(sliver$.SliverPhysicalParentData.__proto__),
    paintOffset: dart.fieldType(dart.legacy(ui.Offset))
  }));
  dart.defineExtensionMethods(sliver$.SliverPhysicalParentData, ['toString']);
  const SliverPhysicalParentData_ContainerParentDataMixin$36 = class SliverPhysicalParentData_ContainerParentDataMixin extends sliver$.SliverPhysicalParentData {};
  (SliverPhysicalParentData_ContainerParentDataMixin$36.new = function() {
    object.ContainerParentDataMixin$(dart.legacy(sliver$.RenderSliver))[dart.mixinNew].call(this);
    SliverPhysicalParentData_ContainerParentDataMixin$36.__proto__.new.call(this);
  }).prototype = SliverPhysicalParentData_ContainerParentDataMixin$36.prototype;
  dart.applyMixin(SliverPhysicalParentData_ContainerParentDataMixin$36, object.ContainerParentDataMixin$(dart.legacy(sliver$.RenderSliver)));
  sliver$.SliverPhysicalContainerParentData = class SliverPhysicalContainerParentData extends SliverPhysicalParentData_ContainerParentDataMixin$36 {};
  (sliver$.SliverPhysicalContainerParentData.new = function() {
    sliver$.SliverPhysicalContainerParentData.__proto__.new.call(this);
    ;
  }).prototype = sliver$.SliverPhysicalContainerParentData.prototype;
  dart.addTypeTests(sliver$.SliverPhysicalContainerParentData);
  dart.addTypeCaches(sliver$.SliverPhysicalContainerParentData);
  dart.setLibraryUri(sliver$.SliverPhysicalContainerParentData, L0);
  var _getRightWayUp = dart.privateName(sliver$, "_getRightWayUp");
  sliver$.RenderSliverHelpers = class RenderSliverHelpers extends core.Object {
    [_getRightWayUp](constraints) {
      if (!(constraints != null)) dart.assertFailed(null, L1, 1613, 12, "constraints != null");
      if (!(constraints.axisDirection != null)) dart.assertFailed(null, L1, 1614, 12, "constraints.axisDirection != null");
      let rightWayUp = null;
      switch (constraints.axisDirection) {
        case C5 || CT.C5:
        case C6 || CT.C6:
        {
          rightWayUp = false;
          break;
        }
        case C3 || CT.C3:
        case C4 || CT.C4:
        {
          rightWayUp = true;
          break;
        }
      }
      if (!(constraints.growthDirection != null)) dart.assertFailed(null, L1, 1626, 12, "constraints.growthDirection != null");
      switch (constraints.growthDirection) {
        case C0 || CT.C0:
        {
          break;
        }
        case C1 || CT.C1:
        {
          rightWayUp = !dart.test(rightWayUp);
          break;
        }
      }
      if (!(rightWayUp != null)) dart.assertFailed(null, L1, 1634, 12, "rightWayUp != null");
      return rightWayUp;
    }
    hitTestBoxChild(result, child, opts) {
      let mainAxisPosition = opts && 'mainAxisPosition' in opts ? opts.mainAxisPosition : null;
      let crossAxisPosition = opts && 'crossAxisPosition' in opts ? opts.crossAxisPosition : null;
      let rightWayUp = this[_getRightWayUp](this.constraints);
      let delta = this.childMainAxisPosition(child);
      let crossAxisDelta = this.childCrossAxisPosition(child);
      let absolutePosition = dart.notNull(mainAxisPosition) - dart.notNull(delta);
      let absoluteCrossAxisPosition = dart.notNull(crossAxisPosition) - dart.notNull(crossAxisDelta);
      let paintOffset = null;
      let transformedPosition = null;
      if (!(this.constraints.axis != null)) dart.assertFailed(null, L1, 1656, 12, "constraints.axis != null");
      switch (this.constraints.axis) {
        case C7 || CT.C7:
        {
          if (!dart.test(rightWayUp)) {
            absolutePosition = dart.notNull(child.size.width) - absolutePosition;
            delta = dart.notNull(this.geometry.paintExtent) - dart.notNull(child.size.width) - dart.notNull(delta);
          }
          paintOffset = new ui.Offset.new(delta, crossAxisDelta);
          transformedPosition = new ui.Offset.new(absolutePosition, absoluteCrossAxisPosition);
          break;
        }
        case C8 || CT.C8:
        {
          if (!dart.test(rightWayUp)) {
            absolutePosition = dart.notNull(child.size.height) - absolutePosition;
            delta = dart.notNull(this.geometry.paintExtent) - dart.notNull(child.size.height) - dart.notNull(delta);
          }
          paintOffset = new ui.Offset.new(crossAxisDelta, delta);
          transformedPosition = new ui.Offset.new(absoluteCrossAxisPosition, absolutePosition);
          break;
        }
      }
      if (!(paintOffset != null)) dart.assertFailed(null, L1, 1675, 12, "paintOffset != null");
      if (!(transformedPosition != null)) dart.assertFailed(null, L1, 1676, 12, "transformedPosition != null");
      return result.addWithPaintOffset({offset: paintOffset, position: null, hitTest: dart.fn((result, _) => child.hitTest(result, {position: transformedPosition}), BoxHitTestResultLAndOffsetLToboolL())});
    }
    applyPaintTransformForBoxChild(child, transform) {
      let rightWayUp = this[_getRightWayUp](this.constraints);
      let delta = this.childMainAxisPosition(child);
      let crossAxisDelta = this.childCrossAxisPosition(child);
      if (!(this.constraints.axis != null)) dart.assertFailed(null, L1, 1699, 12, "constraints.axis != null");
      switch (this.constraints.axis) {
        case C7 || CT.C7:
        {
          if (!dart.test(rightWayUp)) delta = dart.notNull(this.geometry.paintExtent) - dart.notNull(child.size.width) - dart.notNull(delta);
          transform.translate(delta, crossAxisDelta);
          break;
        }
        case C8 || CT.C8:
        {
          if (!dart.test(rightWayUp)) delta = dart.notNull(this.geometry.paintExtent) - dart.notNull(child.size.height) - dart.notNull(delta);
          transform.translate(crossAxisDelta, delta);
          break;
        }
      }
    }
  };
  (sliver$.RenderSliverHelpers.new = function() {
    ;
  }).prototype = sliver$.RenderSliverHelpers.prototype;
  dart.addTypeTests(sliver$.RenderSliverHelpers);
  dart.addTypeCaches(sliver$.RenderSliverHelpers);
  sliver$.RenderSliverHelpers[dart.implements] = () => [sliver$.RenderSliver];
  dart.setMethodSignature(sliver$.RenderSliverHelpers, () => ({
    __proto__: dart.getMethods(sliver$.RenderSliverHelpers.__proto__),
    [_getRightWayUp]: dart.fnType(dart.legacy(core.bool), [dart.legacy(sliver$.SliverConstraints)]),
    hitTestBoxChild: dart.fnType(dart.legacy(core.bool), [dart.legacy(box.BoxHitTestResult), dart.legacy(box.RenderBox)], {crossAxisPosition: dart.legacy(core.double), mainAxisPosition: dart.legacy(core.double)}, {}),
    applyPaintTransformForBoxChild: dart.fnType(dart.void, [dart.legacy(box.RenderBox), dart.legacy(vector_math_64.Matrix4)])
  }));
  dart.setLibraryUri(sliver$.RenderSliverHelpers, L0);
  const RenderSliver_RenderObjectWithChildMixin$36 = class RenderSliver_RenderObjectWithChildMixin extends sliver$.RenderSliver {};
  (RenderSliver_RenderObjectWithChildMixin$36.new = function() {
    object.RenderObjectWithChildMixin$(dart.legacy(box.RenderBox))[dart.mixinNew].call(this);
    RenderSliver_RenderObjectWithChildMixin$36.__proto__.new.call(this);
  }).prototype = RenderSliver_RenderObjectWithChildMixin$36.prototype;
  dart.applyMixin(RenderSliver_RenderObjectWithChildMixin$36, object.RenderObjectWithChildMixin$(dart.legacy(box.RenderBox)));
  const RenderSliver_RenderSliverHelpers$36 = class RenderSliver_RenderSliverHelpers extends RenderSliver_RenderObjectWithChildMixin$36 {};
  (RenderSliver_RenderSliverHelpers$36.new = function() {
    RenderSliver_RenderSliverHelpers$36.__proto__.new.call(this);
  }).prototype = RenderSliver_RenderSliverHelpers$36.prototype;
  dart.applyMixin(RenderSliver_RenderSliverHelpers$36, sliver$.RenderSliverHelpers);
  sliver$.RenderSliverSingleBoxAdapter = class RenderSliverSingleBoxAdapter extends RenderSliver_RenderSliverHelpers$36 {
    setupParentData(child) {
      RenderObjectL().as(child);
      if (!SliverPhysicalParentDataL().is(child.parentData)) child.parentData = new sliver$.SliverPhysicalParentData.new();
    }
    setChildParentData(child, constraints, geometry) {
      let childParentData = SliverPhysicalParentDataL().as(child.parentData);
      if (!(constraints.axisDirection != null)) dart.assertFailed(null, L1, 1748, 12, "constraints.axisDirection != null");
      if (!(constraints.growthDirection != null)) dart.assertFailed(null, L1, 1749, 12, "constraints.growthDirection != null");
      switch (sliver$.applyGrowthDirectionToAxisDirection(constraints.axisDirection, constraints.growthDirection)) {
        case C5 || CT.C5:
        {
          childParentData.paintOffset = new ui.Offset.new(0.0, -(dart.notNull(geometry.scrollExtent) - (dart.notNull(geometry.paintExtent) + dart.notNull(constraints.scrollOffset))));
          break;
        }
        case C4 || CT.C4:
        {
          childParentData.paintOffset = new ui.Offset.new(-dart.notNull(constraints.scrollOffset), 0.0);
          break;
        }
        case C3 || CT.C3:
        {
          childParentData.paintOffset = new ui.Offset.new(0.0, -dart.notNull(constraints.scrollOffset));
          break;
        }
        case C6 || CT.C6:
        {
          childParentData.paintOffset = new ui.Offset.new(-(dart.notNull(geometry.scrollExtent) - (dart.notNull(geometry.paintExtent) + dart.notNull(constraints.scrollOffset))), 0.0);
          break;
        }
      }
      if (!(childParentData.paintOffset != null)) dart.assertFailed(null, L1, 1764, 12, "childParentData.paintOffset != null");
    }
    hitTestChildren(result, opts) {
      let mainAxisPosition = opts && 'mainAxisPosition' in opts ? opts.mainAxisPosition : null;
      let crossAxisPosition = opts && 'crossAxisPosition' in opts ? opts.crossAxisPosition : null;
      if (!(dart.notNull(this.geometry.hitTestExtent) > 0.0)) dart.assertFailed(null, L1, 1769, 12, "geometry.hitTestExtent > 0.0");
      if (this.child != null) return this.hitTestBoxChild(new box.BoxHitTestResult.wrap(result), this.child, {mainAxisPosition: mainAxisPosition, crossAxisPosition: crossAxisPosition});
      return false;
    }
    childMainAxisPosition(child) {
      RenderBoxL().as(child);
      return -dart.notNull(this.constraints.scrollOffset);
    }
    applyPaintTransform(child, transform) {
      RenderObjectL().as(child);
      if (!(child != null)) dart.assertFailed(null, L1, 1782, 12, "child != null");
      if (!dart.equals(child, this.child)) dart.assertFailed(null, L1, 1783, 12, "child == this.child");
      let childParentData = SliverPhysicalParentDataL().as(child.parentData);
      childParentData.applyPaintTransform(transform);
    }
    paint(context, offset) {
      if (this.child != null && dart.test(this.geometry.visible)) {
        let childParentData = SliverPhysicalParentDataL().as(this.child.parentData);
        context.paintChild(this.child, offset['+'](childParentData.paintOffset));
      }
    }
  };
  (sliver$.RenderSliverSingleBoxAdapter.new = function(opts) {
    let child = opts && 'child' in opts ? opts.child : null;
    sliver$.RenderSliverSingleBoxAdapter.__proto__.new.call(this);
    this.child = child;
  }).prototype = sliver$.RenderSliverSingleBoxAdapter.prototype;
  dart.addTypeTests(sliver$.RenderSliverSingleBoxAdapter);
  dart.addTypeCaches(sliver$.RenderSliverSingleBoxAdapter);
  dart.setMethodSignature(sliver$.RenderSliverSingleBoxAdapter, () => ({
    __proto__: dart.getMethods(sliver$.RenderSliverSingleBoxAdapter.__proto__),
    setChildParentData: dart.fnType(dart.void, [dart.legacy(object.RenderObject), dart.legacy(sliver$.SliverConstraints), dart.legacy(sliver$.SliverGeometry)])
  }));
  dart.setLibraryUri(sliver$.RenderSliverSingleBoxAdapter, L0);
  sliver$.RenderSliverToBoxAdapter = class RenderSliverToBoxAdapter extends sliver$.RenderSliverSingleBoxAdapter {
    performLayout() {
      if (this.child == null) {
        this.geometry = sliver$.SliverGeometry.zero;
        return;
      }
      let constraints = this.constraints;
      this.child.layout(constraints.asBoxConstraints(), {parentUsesSize: true});
      let childExtent = null;
      switch (constraints.axis) {
        case C7 || CT.C7:
        {
          childExtent = this.child.size.width;
          break;
        }
        case C8 || CT.C8:
        {
          childExtent = this.child.size.height;
          break;
        }
      }
      if (!(childExtent != null)) dart.assertFailed(null, L1, 1832, 12, "childExtent != null");
      let paintedChildSize = this.calculatePaintOffset(constraints, {from: 0.0, to: childExtent});
      let cacheExtent = this.calculateCacheOffset(constraints, {from: 0.0, to: childExtent});
      if (!paintedChildSize[$isFinite]) dart.assertFailed(null, L1, 1836, 12, "paintedChildSize.isFinite");
      if (!(dart.notNull(paintedChildSize) >= 0.0)) dart.assertFailed(null, L1, 1837, 12, "paintedChildSize >= 0.0");
      this.geometry = new sliver$.SliverGeometry.new({scrollExtent: childExtent, paintExtent: paintedChildSize, cacheExtent: cacheExtent, maxPaintExtent: childExtent, hitTestExtent: paintedChildSize, hasVisualOverflow: dart.notNull(childExtent) > dart.notNull(constraints.remainingPaintExtent) || dart.notNull(constraints.scrollOffset) > 0.0});
      this.setChildParentData(this.child, constraints, this.geometry);
    }
  };
  (sliver$.RenderSliverToBoxAdapter.new = function(opts) {
    let child = opts && 'child' in opts ? opts.child : null;
    sliver$.RenderSliverToBoxAdapter.__proto__.new.call(this, {child: child});
    ;
  }).prototype = sliver$.RenderSliverToBoxAdapter.prototype;
  dart.addTypeTests(sliver$.RenderSliverToBoxAdapter);
  dart.addTypeCaches(sliver$.RenderSliverToBoxAdapter);
  dart.setMethodSignature(sliver$.RenderSliverToBoxAdapter, () => ({
    __proto__: dart.getMethods(sliver$.RenderSliverToBoxAdapter.__proto__),
    performLayout: dart.fnType(dart.void, [])
  }));
  dart.setLibraryUri(sliver$.RenderSliverToBoxAdapter, L0);
  sliver$.applyGrowthDirectionToAxisDirection = function applyGrowthDirectionToAxisDirection(axisDirection, growthDirection) {
    if (!(axisDirection != null)) dart.assertFailed(null, L1, 56, 10, "axisDirection != null");
    if (!(growthDirection != null)) dart.assertFailed(null, L1, 57, 10, "growthDirection != null");
    switch (growthDirection) {
      case C0 || CT.C0:
      {
        return axisDirection;
      }
      case C1 || CT.C1:
      {
        return basic_types.flipAxisDirection(axisDirection);
      }
    }
    return null;
  };
  sliver$.applyGrowthDirectionToScrollDirection = function applyGrowthDirectionToScrollDirection(scrollDirection, growthDirection) {
    if (!(scrollDirection != null)) dart.assertFailed(null, L1, 77, 10, "scrollDirection != null");
    if (!(growthDirection != null)) dart.assertFailed(null, L1, 78, 10, "growthDirection != null");
    switch (growthDirection) {
      case C0 || CT.C0:
      {
        return scrollDirection;
      }
      case C1 || CT.C1:
      {
        return viewport_offset.flipScrollDirection(scrollDirection);
      }
    }
    return null;
  };
  sliver$._debugCompareFloats = function _debugCompareFloats(labelA, valueA, labelB, valueB) {
    return (() => {
      let t10 = JSArrayOfDiagnosticsNodeL().of([]);
      if (valueA[$toStringAsFixed](1) !== valueB[$toStringAsFixed](1))
        t10[$add](new assertions.ErrorDescription.new("The " + dart.str(labelA) + " is " + dart.str(valueA[$toStringAsFixed](1)) + ", but " + "the " + dart.str(labelB) + " is " + dart.str(valueB[$toStringAsFixed](1)) + "."));
      else
        for (let t11 of JSArrayOfDiagnosticsNodeL().of([new assertions.ErrorDescription.new("The " + dart.str(labelA) + " is " + dart.str(valueA) + ", but the " + dart.str(labelB) + " is " + dart.str(valueB) + "."), new assertions.ErrorHint.new("Maybe you have fallen prey to floating point rounding errors, and should explicitly " + "apply the min() or max() functions, or the clamp() method, to the " + dart.str(labelB) + "?")]))
          t10[$add](t11);
      return t10;
    })();
  };
  var _name$0 = dart.privateName(viewport, "_name");
  var C11;
  var C12;
  var C13;
  viewport.CacheExtentStyle = class CacheExtentStyle extends core.Object {
    toString() {
      return this[_name$0];
    }
  };
  (viewport.CacheExtentStyle.new = function(index, _name) {
    this.index = index;
    this[_name$0] = _name;
    ;
  }).prototype = viewport.CacheExtentStyle.prototype;
  dart.addTypeTests(viewport.CacheExtentStyle);
  dart.addTypeCaches(viewport.CacheExtentStyle);
  dart.setMethodSignature(viewport.CacheExtentStyle, () => ({
    __proto__: dart.getMethods(viewport.CacheExtentStyle.__proto__),
    toString: dart.fnType(dart.legacy(core.String), []),
    [$toString]: dart.fnType(dart.legacy(core.String), [])
  }));
  dart.setLibraryUri(viewport.CacheExtentStyle, L2);
  dart.setFieldSignature(viewport.CacheExtentStyle, () => ({
    __proto__: dart.getFields(viewport.CacheExtentStyle.__proto__),
    index: dart.finalFieldType(dart.legacy(core.int)),
    [_name$0]: dart.finalFieldType(dart.legacy(core.String))
  }));
  dart.defineExtensionMethods(viewport.CacheExtentStyle, ['toString']);
  viewport.CacheExtentStyle.pixel = C11 || CT.C11;
  viewport.CacheExtentStyle.viewport = C12 || CT.C12;
  viewport.CacheExtentStyle.values = C13 || CT.C13;
  viewport.RenderAbstractViewport = class RenderAbstractViewport extends object.RenderObject {
    static __() {
      return null;
    }
    static of(object) {
      while (object != null) {
        if (RenderAbstractViewportL().is(object)) return object;
        object = RenderObjectL().as(object.parent);
      }
      return null;
    }
  };
  dart.addTypeTests(viewport.RenderAbstractViewport);
  dart.addTypeCaches(viewport.RenderAbstractViewport);
  dart.setLibraryUri(viewport.RenderAbstractViewport, L2);
  dart.defineLazy(viewport.RenderAbstractViewport, {
    /*viewport.RenderAbstractViewport.defaultCacheExtent*/get defaultCacheExtent() {
      return 250;
    }
  }, true);
  var offset$ = dart.privateName(viewport, "RevealedOffset.offset");
  var rect$ = dart.privateName(viewport, "RevealedOffset.rect");
  viewport.RevealedOffset = class RevealedOffset extends core.Object {
    get offset() {
      return this[offset$];
    }
    set offset(value) {
      super.offset = value;
    }
    get rect() {
      return this[rect$];
    }
    set rect(value) {
      super.rect = value;
    }
    toString() {
      return dart.str(object$.objectRuntimeType(this, "RevealedOffset")) + "(offset: " + dart.str(this.offset) + ", rect: " + dart.str(this.rect) + ")";
    }
  };
  (viewport.RevealedOffset.new = function(opts) {
    let offset = opts && 'offset' in opts ? opts.offset : null;
    let rect = opts && 'rect' in opts ? opts.rect : null;
    this[offset$] = offset;
    this[rect$] = rect;
    if (!(offset != null)) dart.assertFailed(null, L3, 104, 15, "offset != null");
    if (!(rect != null)) dart.assertFailed(null, L3, 105, 15, "rect != null");
    ;
  }).prototype = viewport.RevealedOffset.prototype;
  dart.addTypeTests(viewport.RevealedOffset);
  dart.addTypeCaches(viewport.RevealedOffset);
  dart.setMethodSignature(viewport.RevealedOffset, () => ({
    __proto__: dart.getMethods(viewport.RevealedOffset.__proto__),
    toString: dart.fnType(dart.legacy(core.String), []),
    [$toString]: dart.fnType(dart.legacy(core.String), [])
  }));
  dart.setLibraryUri(viewport.RevealedOffset, L2);
  dart.setFieldSignature(viewport.RevealedOffset, () => ({
    __proto__: dart.getFields(viewport.RevealedOffset.__proto__),
    offset: dart.finalFieldType(dart.legacy(core.double)),
    rect: dart.finalFieldType(dart.legacy(ui.Rect))
  }));
  dart.defineExtensionMethods(viewport.RevealedOffset, ['toString']);
  var _name$1 = dart.privateName(ui, "_name");
  var C14;
  var _calculatedCacheExtent = dart.privateName(viewport, "_calculatedCacheExtent");
  var _clipBehavior = dart.privateName(viewport, "_clipBehavior");
  var _axisDirection = dart.privateName(viewport, "_axisDirection");
  var _crossAxisDirection = dart.privateName(viewport, "_crossAxisDirection");
  var _offset = dart.privateName(viewport, "_offset");
  var _cacheExtent = dart.privateName(viewport, "_cacheExtent");
  var _cacheExtentStyle = dart.privateName(viewport, "_cacheExtentStyle");
  var _paintContents = dart.privateName(viewport, "_paintContents");
  var C15;
  var Duration__duration = dart.privateName(core, "Duration._duration");
  var C16;
  var Cubic_d = dart.privateName(curves, "Cubic.d");
  var Cubic_c = dart.privateName(curves, "Cubic.c");
  var Cubic_b = dart.privateName(curves, "Cubic.b");
  var Cubic_a = dart.privateName(curves, "Cubic.a");
  var C17;
  const _is_RenderViewportBase_default = Symbol('_is_RenderViewportBase_default');
  viewport.RenderViewportBase$ = dart.generic(ParentDataClass => {
    const RenderBox_ContainerRenderObjectMixin$36 = class RenderBox_ContainerRenderObjectMixin extends box.RenderBox {};
    (RenderBox_ContainerRenderObjectMixin$36.new = function() {
      object.ContainerRenderObjectMixin$(dart.legacy(sliver$.RenderSliver), dart.legacy(ParentDataClass))[dart.mixinNew].call(this);
      RenderBox_ContainerRenderObjectMixin$36.__proto__.new.call(this);
    }).prototype = RenderBox_ContainerRenderObjectMixin$36.prototype;
    dart.applyMixin(RenderBox_ContainerRenderObjectMixin$36, object.ContainerRenderObjectMixin$(dart.legacy(sliver$.RenderSliver), dart.legacy(ParentDataClass)));
    class RenderViewportBase extends RenderBox_ContainerRenderObjectMixin$36 {
      describeSemanticsConfiguration(config) {
        super.describeSemanticsConfiguration(config);
        config.addTagForChildren(viewport.RenderViewport.useTwoPaneSemantics);
      }
      visitChildrenForSemantics(visitor) {
        this.childrenInPaintOrder[$where](dart.fn(sliver => dart.test(sliver.geometry.visible) || dart.notNull(sliver.geometry.cacheExtent) > 0.0, RenderSliverLToboolL()))[$forEach](visitor);
      }
      get axisDirection() {
        return this[_axisDirection];
      }
      set axisDirection(value) {
        if (!(value != null)) dart.assertFailed(null, L3, 213, 12, "value != null");
        if (value == this[_axisDirection]) return;
        this[_axisDirection] = value;
        this.markNeedsLayout();
      }
      get crossAxisDirection() {
        return this[_crossAxisDirection];
      }
      set crossAxisDirection(value) {
        if (!(value != null)) dart.assertFailed(null, L3, 229, 12, "value != null");
        if (value == this[_crossAxisDirection]) return;
        this[_crossAxisDirection] = value;
        this.markNeedsLayout();
      }
      get axis() {
        return basic_types.axisDirectionToAxis(this.axisDirection);
      }
      get offset() {
        return this[_offset];
      }
      set offset(value) {
        if (!(value != null)) dart.assertFailed(null, L3, 251, 12, "value != null");
        if (dart.equals(value, this[_offset])) return;
        if (dart.test(this.attached)) this[_offset].removeListener(dart.bind(this, 'markNeedsLayout'));
        this[_offset] = value;
        if (dart.test(this.attached)) this[_offset].addListener(dart.bind(this, 'markNeedsLayout'));
        this.markNeedsLayout();
      }
      get cacheExtent() {
        return this[_cacheExtent];
      }
      set cacheExtent(value) {
        let t12;
        value = (t12 = value, t12 == null ? 250 : t12);
        if (!(value != null)) dart.assertFailed(null, L3, 287, 12, "value != null");
        if (value == this[_cacheExtent]) return;
        this[_cacheExtent] = value;
        this.markNeedsLayout();
      }
      get cacheExtentStyle() {
        return this[_cacheExtentStyle];
      }
      set cacheExtentStyle(value) {
        if (!(value != null)) dart.assertFailed(null, L3, 314, 12, "value != null");
        if (value == this[_cacheExtentStyle]) {
          return;
        }
        this[_cacheExtentStyle] = value;
        this.markNeedsLayout();
      }
      get clipBehavior() {
        return this[_clipBehavior];
      }
      set clipBehavior(value) {
        if (!(value != null)) dart.assertFailed(null, L3, 328, 12, "value != null");
        if (!dart.equals(value, this[_clipBehavior])) {
          this[_clipBehavior] = value;
          this.markNeedsPaint();
          this.markNeedsSemanticsUpdate();
        }
      }
      attach(owner) {
        PipelineOwnerL().as(owner);
        super.attach(owner);
        this[_offset].addListener(dart.bind(this, 'markNeedsLayout'));
      }
      detach() {
        this[_offset].removeListener(dart.bind(this, 'markNeedsLayout'));
        super.detach();
      }
      debugThrowIfNotCheckingIntrinsics() {
        if (!dart.test(dart.fn(() => {
          if (!dart.test(object.RenderObject.debugCheckingIntrinsics)) {
            if (!!RenderShrinkWrappingViewportL().is(this)) dart.assertFailed(null, L3, 359, 16, "this is! RenderShrinkWrappingViewport");
            dart.throw(new assertions.FlutterError.fromParts(JSArrayOfDiagnosticsNodeL().of([new assertions.ErrorSummary.new(dart.str(this.runtimeType) + " does not support returning intrinsic dimensions."), new assertions.ErrorDescription.new("Calculating the intrinsic dimensions would require instantiating every child of " + "the viewport, which defeats the point of viewports being lazy."), new assertions.ErrorHint.new("If you are merely trying to shrink-wrap the viewport in the main axis direction, " + "consider a RenderShrinkWrappingViewport render object (ShrinkWrappingViewport widget), " + "which achieves that effect without implementing the intrinsic dimension API.")])));
          }
          return true;
        }, VoidToboolL())())) dart.assertFailed(null, L3, 357, 12, "() {\r\n      if (!RenderObject.debugCheckingIntrinsics) {\r\n        assert(this is! RenderShrinkWrappingViewport); // it has its own message\r\n        throw FlutterError.fromParts(<DiagnosticsNode>[\r\n          ErrorSummary('$runtimeType does not support returning intrinsic dimensions.'),\r\n          ErrorDescription(\r\n            'Calculating the intrinsic dimensions would require instantiating every child of '\r\n            'the viewport, which defeats the point of viewports being lazy.',\r\n          ),\r\n          ErrorHint(\r\n            'If you are merely trying to shrink-wrap the viewport in the main axis direction, '\r\n            'consider a RenderShrinkWrappingViewport render object (ShrinkWrappingViewport widget), '\r\n            'which achieves that effect without implementing the intrinsic dimension API.'\r\n          ),\r\n        ]);\r\n      }\r\n      return true;\r\n    }()");
        return true;
      }
      computeMinIntrinsicWidth(height) {
        if (!dart.test(this.debugThrowIfNotCheckingIntrinsics())) dart.assertFailed(null, L3, 380, 12, "debugThrowIfNotCheckingIntrinsics()");
        return 0.0;
      }
      computeMaxIntrinsicWidth(height) {
        if (!dart.test(this.debugThrowIfNotCheckingIntrinsics())) dart.assertFailed(null, L3, 386, 12, "debugThrowIfNotCheckingIntrinsics()");
        return 0.0;
      }
      computeMinIntrinsicHeight(width) {
        if (!dart.test(this.debugThrowIfNotCheckingIntrinsics())) dart.assertFailed(null, L3, 392, 12, "debugThrowIfNotCheckingIntrinsics()");
        return 0.0;
      }
      computeMaxIntrinsicHeight(width) {
        if (!dart.test(this.debugThrowIfNotCheckingIntrinsics())) dart.assertFailed(null, L3, 398, 12, "debugThrowIfNotCheckingIntrinsics()");
        return 0.0;
      }
      get isRepaintBoundary() {
        return true;
      }
      layoutChildSequence(opts) {
        let child = opts && 'child' in opts ? opts.child : null;
        let scrollOffset = opts && 'scrollOffset' in opts ? opts.scrollOffset : null;
        let overlap = opts && 'overlap' in opts ? opts.overlap : null;
        let layoutOffset = opts && 'layoutOffset' in opts ? opts.layoutOffset : null;
        let remainingPaintExtent = opts && 'remainingPaintExtent' in opts ? opts.remainingPaintExtent : null;
        let mainAxisExtent = opts && 'mainAxisExtent' in opts ? opts.mainAxisExtent : null;
        let crossAxisExtent = opts && 'crossAxisExtent' in opts ? opts.crossAxisExtent : null;
        let growthDirection = opts && 'growthDirection' in opts ? opts.growthDirection : null;
        let advance = opts && 'advance' in opts ? opts.advance : null;
        let remainingCacheExtent = opts && 'remainingCacheExtent' in opts ? opts.remainingCacheExtent : null;
        let cacheOrigin = opts && 'cacheOrigin' in opts ? opts.cacheOrigin : null;
        if (!scrollOffset[$isFinite]) dart.assertFailed(null, L3, 449, 12, "scrollOffset.isFinite");
        if (!(dart.notNull(scrollOffset) >= 0.0)) dart.assertFailed(null, L3, 450, 12, "scrollOffset >= 0.0");
        let initialLayoutOffset = layoutOffset;
        let adjustedUserScrollDirection = sliver$.applyGrowthDirectionToScrollDirection(this.offset.userScrollDirection, growthDirection);
        if (!(adjustedUserScrollDirection != null)) dart.assertFailed(null, L3, 454, 12, "adjustedUserScrollDirection != null");
        let maxPaintOffset = dart.notNull(layoutOffset) + dart.notNull(overlap);
        let precedingScrollExtent = 0.0;
        while (child != null) {
          let sliverScrollOffset = dart.notNull(scrollOffset) <= 0.0 ? 0.0 : scrollOffset;
          let correctedCacheOrigin = math.max(doubleL(), cacheOrigin, -dart.notNull(sliverScrollOffset));
          let cacheExtentCorrection = dart.notNull(cacheOrigin) - correctedCacheOrigin;
          if (!(dart.notNull(sliverScrollOffset) >= correctedCacheOrigin[$abs]())) dart.assertFailed(null, L3, 466, 14, "sliverScrollOffset >= correctedCacheOrigin.abs()");
          if (!(correctedCacheOrigin <= 0.0)) dart.assertFailed(null, L3, 467, 14, "correctedCacheOrigin <= 0.0");
          if (!(dart.notNull(sliverScrollOffset) >= 0.0)) dart.assertFailed(null, L3, 468, 14, "sliverScrollOffset >= 0.0");
          if (!(cacheExtentCorrection <= 0.0)) dart.assertFailed(null, L3, 469, 14, "cacheExtentCorrection <= 0.0");
          child.layout(new sliver$.SliverConstraints.new({axisDirection: this.axisDirection, growthDirection: growthDirection, userScrollDirection: adjustedUserScrollDirection, scrollOffset: sliverScrollOffset, precedingScrollExtent: precedingScrollExtent, overlap: maxPaintOffset - dart.notNull(layoutOffset), remainingPaintExtent: math.max(doubleL(), 0.0, dart.notNull(remainingPaintExtent) - dart.notNull(layoutOffset) + dart.notNull(initialLayoutOffset)), crossAxisExtent: crossAxisExtent, crossAxisDirection: this.crossAxisDirection, viewportMainAxisExtent: mainAxisExtent, remainingCacheExtent: math.max(doubleL(), 0.0, dart.notNull(remainingCacheExtent) + cacheExtentCorrection), cacheOrigin: correctedCacheOrigin}), {parentUsesSize: true});
          let childLayoutGeometry = child.geometry;
          if (!dart.test(childLayoutGeometry.debugAssertIsValid())) dart.assertFailed(null, L3, 487, 14, "childLayoutGeometry.debugAssertIsValid()");
          if (childLayoutGeometry.scrollOffsetCorrection != null) return childLayoutGeometry.scrollOffsetCorrection;
          let effectiveLayoutOffset = dart.notNull(layoutOffset) + dart.notNull(childLayoutGeometry.paintOrigin);
          if (dart.test(childLayoutGeometry.visible) || dart.notNull(scrollOffset) > 0) {
            this.updateChildLayoutOffset(child, effectiveLayoutOffset, growthDirection);
          } else {
            this.updateChildLayoutOffset(child, -dart.notNull(scrollOffset) + dart.notNull(initialLayoutOffset), growthDirection);
          }
          maxPaintOffset = math.max(doubleL(), effectiveLayoutOffset + dart.notNull(childLayoutGeometry.paintExtent), maxPaintOffset);
          scrollOffset = dart.notNull(scrollOffset) - dart.notNull(childLayoutGeometry.scrollExtent);
          precedingScrollExtent = precedingScrollExtent + dart.notNull(childLayoutGeometry.scrollExtent);
          layoutOffset = dart.notNull(layoutOffset) + dart.notNull(childLayoutGeometry.layoutExtent);
          if (childLayoutGeometry.cacheExtent !== 0.0) {
            remainingCacheExtent = dart.notNull(remainingCacheExtent) - (dart.notNull(childLayoutGeometry.cacheExtent) - cacheExtentCorrection);
            cacheOrigin = math.min(doubleL(), correctedCacheOrigin + dart.notNull(childLayoutGeometry.cacheExtent), 0.0);
          }
          this.updateOutOfBandData(growthDirection, childLayoutGeometry);
          child = advance(child);
        }
        return 0.0;
      }
      describeApproximatePaintClip(child) {
        RenderSliverL().as(child);
        let viewportClip = ui.Offset.zero['&'](this.size);
        if (child.constraints.overlap === 0 || !child.constraints.viewportMainAxisExtent[$isFinite]) {
          return viewportClip;
        }
        let left = viewportClip.left;
        let right = viewportClip.right;
        let top = viewportClip.top;
        let bottom = viewportClip.bottom;
        let startOfOverlap = dart.notNull(child.constraints.viewportMainAxisExtent) - dart.notNull(child.constraints.remainingPaintExtent);
        let overlapCorrection = startOfOverlap + dart.notNull(child.constraints.overlap);
        switch (sliver$.applyGrowthDirectionToAxisDirection(this.axisDirection, child.constraints.growthDirection)) {
          case C3 || CT.C3:
          {
            top = dart.notNull(top) + overlapCorrection;
            break;
          }
          case C5 || CT.C5:
          {
            bottom = dart.notNull(bottom) - overlapCorrection;
            break;
          }
          case C4 || CT.C4:
          {
            left = dart.notNull(left) + overlapCorrection;
            break;
          }
          case C6 || CT.C6:
          {
            right = dart.notNull(right) - overlapCorrection;
            break;
          }
        }
        return new ui.Rect.fromLTRB(left, top, right, bottom);
      }
      describeSemanticsClip(child) {
        RenderSliverL().as(child);
        if (!(this.axis != null)) dart.assertFailed(null, L3, 567, 12, "axis != null");
        if (this[_calculatedCacheExtent] == null) {
          return this.semanticBounds;
        }
        switch (this.axis) {
          case C8 || CT.C8:
          {
            return new ui.Rect.fromLTRB(this.semanticBounds.left, dart.notNull(this.semanticBounds.top) - dart.notNull(this[_calculatedCacheExtent]), this.semanticBounds.right, dart.notNull(this.semanticBounds.bottom) + dart.notNull(this[_calculatedCacheExtent]));
          }
          case C7 || CT.C7:
          {
            return new ui.Rect.fromLTRB(dart.notNull(this.semanticBounds.left) - dart.notNull(this[_calculatedCacheExtent]), this.semanticBounds.top, dart.notNull(this.semanticBounds.right) + dart.notNull(this[_calculatedCacheExtent]), this.semanticBounds.bottom);
          }
        }
        return null;
      }
      paint(context, offset) {
        if (this.firstChild == null) return;
        if (dart.test(this.hasVisualOverflow) && !dart.equals(this.clipBehavior, ui.Clip.none)) {
          context.pushClipRect(this.needsCompositing, offset, ui.Offset.zero['&'](this.size), dart.bind(this, _paintContents), {clipBehavior: this.clipBehavior});
        } else {
          this[_paintContents](context, offset);
        }
      }
      [_paintContents](context, offset) {
        for (let child of this.childrenInPaintOrder) {
          if (dart.test(child.geometry.visible)) context.paintChild(child, offset['+'](this.paintOffsetOf(child)));
        }
      }
      debugPaintSize(context, offset) {
        if (!dart.test(dart.fn(() => {
          let t12;
          super.debugPaintSize(context, offset);
          let paint = (t12 = ui.Paint.new(), (() => {
            t12.style = ui.PaintingStyle.stroke;
            t12.strokeWidth = 1.0;
            t12.color = C15 || CT.C15;
            return t12;
          })());
          let canvas = context.canvas;
          let child = this.firstChild;
          while (child != null) {
            let size = null;
            switch (this.axis) {
              case C8 || CT.C8:
              {
                size = new ui.Size.new(child.constraints.crossAxisExtent, child.geometry.layoutExtent);
                break;
              }
              case C7 || CT.C7:
              {
                size = new ui.Size.new(child.geometry.layoutExtent, child.constraints.crossAxisExtent);
                break;
              }
            }
            if (!(size != null)) dart.assertFailed(null, L3, 630, 16, "size != null");
            canvas.drawRect(offset['+'](this.paintOffsetOf(child))['&'](size).deflate(0.5), paint);
            child = this.childAfter(child);
          }
          return true;
        }, VoidToboolL())())) dart.assertFailed(null, L3, 612, 12, "() {\r\n      super.debugPaintSize(context, offset);\r\n      final Paint paint = Paint()\r\n        ..style = PaintingStyle.stroke\r\n        ..strokeWidth = 1.0\r\n        ..color = const Color(0xFF00FF00);\r\n      final Canvas canvas = context.canvas;\r\n      RenderSliver child = firstChild;\r\n      while (child != null) {\r\n        Size size;\r\n        switch (axis) {\r\n          case Axis.vertical:\r\n            size = Size(child.constraints.crossAxisExtent, child.geometry.layoutExtent);\r\n            break;\r\n          case Axis.horizontal:\r\n            size = Size(child.geometry.layoutExtent, child.constraints.crossAxisExtent);\r\n            break;\r\n        }\r\n        assert(size != null);\r\n        canvas.drawRect(((offset + paintOffsetOf(child)) & size).deflate(0.5), paint);\r\n        child = childAfter(child);\r\n      }\r\n      return true;\r\n    }()");
      }
      hitTestChildren(result, opts) {
        let position = opts && 'position' in opts ? opts.position : null;
        let mainAxisPosition = null;
        let crossAxisPosition = null;
        switch (this.axis) {
          case C8 || CT.C8:
          {
            mainAxisPosition = position.dy;
            crossAxisPosition = position.dx;
            break;
          }
          case C7 || CT.C7:
          {
            mainAxisPosition = position.dx;
            crossAxisPosition = position.dy;
            break;
          }
        }
        if (!(mainAxisPosition != null)) dart.assertFailed(null, L3, 651, 12, "mainAxisPosition != null");
        if (!(crossAxisPosition != null)) dart.assertFailed(null, L3, 652, 12, "crossAxisPosition != null");
        let sliverResult = new sliver$.SliverHitTestResult.wrap(result);
        for (let child of this.childrenInHitTestOrder) {
          if (!dart.test(child.geometry.visible)) {
            continue;
          }
          let transform = vector_math_64.Matrix4.identity();
          this.applyPaintTransform(child, transform);
          let isHit = result.addWithPaintTransform({transform: transform, position: null, hitTest: dart.fn((result, _) => child.hitTest(sliverResult, {mainAxisPosition: this.computeChildMainAxisPosition(child, mainAxisPosition), crossAxisPosition: crossAxisPosition}), BoxHitTestResultLAndOffsetLToboolL())});
          if (dart.test(isHit)) {
            return true;
          }
        }
        return false;
      }
      getOffsetToReveal(target, alignment, opts) {
        let rect = opts && 'rect' in opts ? opts.rect : null;
        let leadingScrollOffset = 0.0;
        let targetMainAxisExtent = null;
        rect == null ? rect = target.paintBounds : null;
        let child = target;
        let pivot = null;
        let onlySlivers = RenderSliverL().is(target);
        while (!dart.equals(child.parent, this)) {
          let parent = RenderObjectL().as(child.parent);
          if (!(parent != null)) dart.assertFailed(dart.str(target) + " must be a descendant of " + dart.str(this), L3, 692, 14, "parent != null");
          if (RenderBoxL().is(child)) {
            pivot = child;
          }
          if (RenderSliverL().is(parent)) {
            leadingScrollOffset = dart.notNull(leadingScrollOffset) + dart.notNull(parent.childScrollOffset(child));
          } else {
            onlySlivers = false;
            leadingScrollOffset = 0.0;
          }
          child = parent;
        }
        if (pivot != null) {
          if (!(pivot.parent != null)) dart.assertFailed(null, L3, 706, 14, "pivot.parent != null");
          if (!!dart.equals(pivot.parent, this)) dart.assertFailed(null, L3, 707, 14, "pivot.parent != this");
          if (!!dart.equals(pivot, this)) dart.assertFailed(null, L3, 708, 14, "pivot != this");
          if (!RenderSliverL().is(pivot.parent)) dart.assertFailed(null, L3, 709, 14, "pivot.parent is RenderSliver");
          let pivotParent = RenderSliverL().as(pivot.parent);
          let transform = target.getTransformTo(pivot);
          let bounds = matrix_utils.MatrixUtils.transformRect(transform, rect);
          let growthDirection = pivotParent.constraints.growthDirection;
          switch (sliver$.applyGrowthDirectionToAxisDirection(this.axisDirection, growthDirection)) {
            case C5 || CT.C5:
            {
              let offset = null;
              switch (growthDirection) {
                case C0 || CT.C0:
                {
                  offset = bounds.bottom;
                  break;
                }
                case C1 || CT.C1:
                {
                  offset = bounds.top;
                  break;
                }
              }
              leadingScrollOffset = dart.notNull(leadingScrollOffset) + (dart.notNull(pivot.size.height) - dart.notNull(offset));
              targetMainAxisExtent = bounds.height;
              break;
            }
            case C4 || CT.C4:
            {
              let offset = null;
              switch (growthDirection) {
                case C0 || CT.C0:
                {
                  offset = bounds.left;
                  break;
                }
                case C1 || CT.C1:
                {
                  offset = bounds.right;
                  break;
                }
              }
              leadingScrollOffset = dart.notNull(leadingScrollOffset) + dart.notNull(offset);
              targetMainAxisExtent = bounds.width;
              break;
            }
            case C3 || CT.C3:
            {
              let offset = null;
              switch (growthDirection) {
                case C0 || CT.C0:
                {
                  offset = bounds.top;
                  break;
                }
                case C1 || CT.C1:
                {
                  offset = bounds.bottom;
                  break;
                }
              }
              leadingScrollOffset = dart.notNull(leadingScrollOffset) + dart.notNull(offset);
              targetMainAxisExtent = bounds.height;
              break;
            }
            case C6 || CT.C6:
            {
              let offset = null;
              switch (growthDirection) {
                case C0 || CT.C0:
                {
                  offset = bounds.right;
                  break;
                }
                case C1 || CT.C1:
                {
                  offset = bounds.left;
                  break;
                }
              }
              leadingScrollOffset = dart.notNull(leadingScrollOffset) + (dart.notNull(pivot.size.width) - dart.notNull(offset));
              targetMainAxisExtent = bounds.width;
              break;
            }
          }
        } else if (onlySlivers) {
          let targetSliver = RenderSliverL().as(target);
          targetMainAxisExtent = targetSliver.geometry.scrollExtent;
        } else {
          return new viewport.RevealedOffset.new({offset: this.offset.pixels, rect: rect});
        }
        if (!dart.equals(child.parent, this)) dart.assertFailed(null, L3, 777, 12, "child.parent == this");
        if (!RenderSliverL().is(child)) dart.assertFailed(null, L3, 778, 12, "child is RenderSliver");
        let sliver = RenderSliverL().as(child);
        let extentOfPinnedSlivers = this.maxScrollObstructionExtentBefore(sliver);
        leadingScrollOffset = this.scrollOffsetOf(sliver, leadingScrollOffset);
        switch (sliver.constraints.growthDirection) {
          case C0 || CT.C0:
          {
            leadingScrollOffset = dart.notNull(leadingScrollOffset) - dart.notNull(extentOfPinnedSlivers);
            break;
          }
          case C1 || CT.C1:
          {
            break;
          }
        }
        let mainAxisExtent = null;
        switch (this.axis) {
          case C7 || CT.C7:
          {
            mainAxisExtent = dart.notNull(this.size.width) - dart.notNull(extentOfPinnedSlivers);
            break;
          }
          case C8 || CT.C8:
          {
            mainAxisExtent = dart.notNull(this.size.height) - dart.notNull(extentOfPinnedSlivers);
            break;
          }
        }
        let targetOffset = dart.notNull(leadingScrollOffset) - (dart.notNull(mainAxisExtent) - dart.notNull(targetMainAxisExtent)) * dart.notNull(alignment);
        let offsetDifference = dart.notNull(this.offset.pixels) - targetOffset;
        let transform = target.getTransformTo(this);
        let targetRect = matrix_utils.MatrixUtils.transformRect(transform, rect);
        switch (this.axisDirection) {
          case C3 || CT.C3:
          {
            targetRect = targetRect.translate(0.0, offsetDifference);
            break;
          }
          case C4 || CT.C4:
          {
            targetRect = targetRect.translate(offsetDifference, 0.0);
            break;
          }
          case C5 || CT.C5:
          {
            targetRect = targetRect.translate(0.0, -offsetDifference);
            break;
          }
          case C6 || CT.C6:
          {
            targetRect = targetRect.translate(-offsetDifference, 0.0);
            break;
          }
        }
        return new viewport.RevealedOffset.new({offset: targetOffset, rect: targetRect});
      }
      computeAbsolutePaintOffset(child, layoutOffset, growthDirection) {
        if (!dart.test(this.hasSize)) dart.assertFailed(null, L3, 837, 12, "hasSize");
        if (!(this.axisDirection != null)) dart.assertFailed(null, L3, 838, 12, "axisDirection != null");
        if (!(growthDirection != null)) dart.assertFailed(null, L3, 839, 12, "growthDirection != null");
        if (!(child != null)) dart.assertFailed(null, L3, 840, 12, "child != null");
        if (!(child.geometry != null)) dart.assertFailed(null, L3, 841, 12, "child.geometry != null");
        switch (sliver$.applyGrowthDirectionToAxisDirection(this.axisDirection, growthDirection)) {
          case C5 || CT.C5:
          {
            return new ui.Offset.new(0.0, dart.notNull(this.size.height) - (dart.notNull(layoutOffset) + dart.notNull(child.geometry.paintExtent)));
          }
          case C4 || CT.C4:
          {
            return new ui.Offset.new(layoutOffset, 0.0);
          }
          case C3 || CT.C3:
          {
            return new ui.Offset.new(0.0, layoutOffset);
          }
          case C6 || CT.C6:
          {
            return new ui.Offset.new(dart.notNull(this.size.width) - (dart.notNull(layoutOffset) + dart.notNull(child.geometry.paintExtent)), 0.0);
          }
        }
        return null;
      }
      debugFillProperties(properties) {
        super.debugFillProperties(properties);
        properties.add(new (EnumPropertyOfAxisDirectionL()).new("axisDirection", this.axisDirection));
        properties.add(new (EnumPropertyOfAxisDirectionL()).new("crossAxisDirection", this.crossAxisDirection));
        properties.add(new (DiagnosticsPropertyOfViewportOffsetL()).new("offset", this.offset));
      }
      debugDescribeChildren() {
        let children = JSArrayOfDiagnosticsNodeL().of([]);
        let child = this.firstChild;
        if (child == null) return children;
        let count = this.indexOfFirstChild;
        while (true) {
          children[$add](child.toDiagnosticsNode({name: this.labelForChild(count)}));
          if (dart.equals(child, this.lastChild)) break;
          count = dart.notNull(count) + 1;
          child = this.childAfter(child);
        }
        return children;
      }
      showOnScreen(opts) {
        let descendant = opts && 'descendant' in opts ? opts.descendant : null;
        let rect = opts && 'rect' in opts ? opts.rect : null;
        let duration = opts && 'duration' in opts ? opts.duration : C16 || CT.C16;
        let curve = opts && 'curve' in opts ? opts.curve : C17 || CT.C17;
        if (!dart.test(this.offset.allowImplicitScrolling)) {
          return super.showOnScreen({descendant: descendant, rect: rect, duration: duration, curve: curve});
        }
        let newRect = viewport.RenderViewportBase.showInViewport({descendant: descendant, viewport: this, offset: this.offset, rect: rect, duration: duration, curve: curve});
        super.showOnScreen({rect: newRect, duration: duration, curve: curve});
      }
      static showInViewport(opts) {
        let t12;
        let descendant = opts && 'descendant' in opts ? opts.descendant : null;
        let rect = opts && 'rect' in opts ? opts.rect : null;
        let viewport = opts && 'viewport' in opts ? opts.viewport : null;
        let offset = opts && 'offset' in opts ? opts.offset : null;
        let duration = opts && 'duration' in opts ? opts.duration : C16 || CT.C16;
        let curve = opts && 'curve' in opts ? opts.curve : C17 || CT.C17;
        if (!(viewport != null)) dart.assertFailed(null, L3, 1051, 12, "viewport != null");
        if (!(offset != null)) dart.assertFailed(null, L3, 1052, 12, "offset != null");
        if (descendant == null) {
          return rect;
        }
        let leadingEdgeOffset = viewport.getOffsetToReveal(descendant, 0.0, {rect: rect});
        let trailingEdgeOffset = viewport.getOffsetToReveal(descendant, 1.0, {rect: rect});
        let currentOffset = offset.pixels;
        let targetOffset = null;
        if (dart.notNull(leadingEdgeOffset.offset) < dart.notNull(trailingEdgeOffset.offset)) {
          let leadingEdgeDiff = (dart.notNull(offset.pixels) - dart.notNull(leadingEdgeOffset.offset))[$abs]();
          let trailingEdgeDiff = (dart.notNull(offset.pixels) - dart.notNull(trailingEdgeOffset.offset))[$abs]();
          targetOffset = leadingEdgeDiff < trailingEdgeDiff ? leadingEdgeOffset : trailingEdgeOffset;
        } else if (dart.notNull(currentOffset) > dart.notNull(leadingEdgeOffset.offset)) {
          targetOffset = leadingEdgeOffset;
        } else if (dart.notNull(currentOffset) < dart.notNull(trailingEdgeOffset.offset)) {
          targetOffset = trailingEdgeOffset;
        } else {
          let transform = descendant.getTransformTo(RenderObjectL().as(viewport.parent));
          return matrix_utils.MatrixUtils.transformRect(transform, (t12 = rect, t12 == null ? descendant.paintBounds : t12));
        }
        if (!(targetOffset != null)) dart.assertFailed(null, L3, 1103, 12, "targetOffset != null");
        offset.moveTo(targetOffset.offset, {duration: duration, curve: curve});
        return targetOffset.rect;
      }
    }
    (RenderViewportBase.new = function(opts) {
      let t12;
      let axisDirection = opts && 'axisDirection' in opts ? opts.axisDirection : C3 || CT.C3;
      let crossAxisDirection = opts && 'crossAxisDirection' in opts ? opts.crossAxisDirection : null;
      let offset = opts && 'offset' in opts ? opts.offset : null;
      let cacheExtent = opts && 'cacheExtent' in opts ? opts.cacheExtent : null;
      let cacheExtentStyle = opts && 'cacheExtentStyle' in opts ? opts.cacheExtentStyle : C11 || CT.C11;
      let clipBehavior = opts && 'clipBehavior' in opts ? opts.clipBehavior : C14 || CT.C14;
      this[_calculatedCacheExtent] = null;
      this[_clipBehavior] = ui.Clip.hardEdge;
      if (!(axisDirection != null)) dart.assertFailed(null, L3, 177, 15, "axisDirection != null");
      if (!(crossAxisDirection != null)) dart.assertFailed(null, L3, 178, 15, "crossAxisDirection != null");
      if (!(offset != null)) dart.assertFailed(null, L3, 179, 15, "offset != null");
      if (!(basic_types.axisDirectionToAxis(axisDirection) != basic_types.axisDirectionToAxis(crossAxisDirection))) dart.assertFailed(null, L3, 180, 15, "axisDirectionToAxis(axisDirection) != axisDirectionToAxis(crossAxisDirection)");
      if (!(cacheExtentStyle != null)) dart.assertFailed(null, L3, 181, 15, "cacheExtentStyle != null");
      if (!(cacheExtent != null || cacheExtentStyle == viewport.CacheExtentStyle.pixel)) dart.assertFailed(null, L3, 182, 15, "cacheExtent != null || cacheExtentStyle == CacheExtentStyle.pixel");
      if (!(clipBehavior != null)) dart.assertFailed(null, L3, 183, 15, "clipBehavior != null");
      this[_axisDirection] = axisDirection;
      this[_crossAxisDirection] = crossAxisDirection;
      this[_offset] = offset;
      this[_cacheExtent] = (t12 = cacheExtent, t12 == null ? 250 : t12);
      this[_cacheExtentStyle] = cacheExtentStyle;
      this[_clipBehavior] = clipBehavior;
      RenderViewportBase.__proto__.new.call(this);
      ;
    }).prototype = RenderViewportBase.prototype;
    dart.addTypeTests(RenderViewportBase);
    RenderViewportBase.prototype[_is_RenderViewportBase_default] = true;
    dart.addTypeCaches(RenderViewportBase);
    RenderViewportBase[dart.implements] = () => [viewport.RenderAbstractViewport];
    dart.setMethodSignature(RenderViewportBase, () => ({
      __proto__: dart.getMethods(RenderViewportBase.__proto__),
      debugThrowIfNotCheckingIntrinsics: dart.fnType(dart.legacy(core.bool), []),
      layoutChildSequence: dart.fnType(dart.legacy(core.double), [], {advance: dart.legacy(dart.fnType(dart.legacy(sliver$.RenderSliver), [dart.legacy(sliver$.RenderSliver)])), cacheOrigin: dart.legacy(core.double), child: dart.legacy(sliver$.RenderSliver), crossAxisExtent: dart.legacy(core.double), growthDirection: dart.legacy(sliver$.GrowthDirection), layoutOffset: dart.legacy(core.double), mainAxisExtent: dart.legacy(core.double), overlap: dart.legacy(core.double), remainingCacheExtent: dart.legacy(core.double), remainingPaintExtent: dart.legacy(core.double), scrollOffset: dart.legacy(core.double)}, {}),
      [_paintContents]: dart.fnType(dart.void, [dart.legacy(object.PaintingContext), dart.legacy(ui.Offset)]),
      getOffsetToReveal: dart.fnType(dart.legacy(viewport.RevealedOffset), [dart.legacy(object.RenderObject), dart.legacy(core.double)], {rect: dart.legacy(ui.Rect)}, {}),
      computeAbsolutePaintOffset: dart.fnType(dart.legacy(ui.Offset), [dart.legacy(sliver$.RenderSliver), dart.legacy(core.double), dart.legacy(sliver$.GrowthDirection)])
    }));
    dart.setGetterSignature(RenderViewportBase, () => ({
      __proto__: dart.getGetters(RenderViewportBase.__proto__),
      axisDirection: dart.legacy(basic_types.AxisDirection),
      crossAxisDirection: dart.legacy(basic_types.AxisDirection),
      axis: dart.legacy(basic_types.Axis),
      offset: dart.legacy(viewport_offset.ViewportOffset),
      cacheExtent: dart.legacy(core.double),
      cacheExtentStyle: dart.legacy(viewport.CacheExtentStyle),
      clipBehavior: dart.legacy(ui.Clip)
    }));
    dart.setSetterSignature(RenderViewportBase, () => ({
      __proto__: dart.getSetters(RenderViewportBase.__proto__),
      axisDirection: dart.legacy(basic_types.AxisDirection),
      crossAxisDirection: dart.legacy(basic_types.AxisDirection),
      offset: dart.legacy(viewport_offset.ViewportOffset),
      cacheExtent: dart.legacy(core.double),
      cacheExtentStyle: dart.legacy(viewport.CacheExtentStyle),
      clipBehavior: dart.legacy(ui.Clip)
    }));
    dart.setLibraryUri(RenderViewportBase, L2);
    dart.setFieldSignature(RenderViewportBase, () => ({
      __proto__: dart.getFields(RenderViewportBase.__proto__),
      [_axisDirection]: dart.fieldType(dart.legacy(basic_types.AxisDirection)),
      [_crossAxisDirection]: dart.fieldType(dart.legacy(basic_types.AxisDirection)),
      [_offset]: dart.fieldType(dart.legacy(viewport_offset.ViewportOffset)),
      [_cacheExtent]: dart.fieldType(dart.legacy(core.double)),
      [_calculatedCacheExtent]: dart.fieldType(dart.legacy(core.double)),
      [_cacheExtentStyle]: dart.fieldType(dart.legacy(viewport.CacheExtentStyle)),
      [_clipBehavior]: dart.fieldType(dart.legacy(ui.Clip))
    }));
    return RenderViewportBase;
  });
  viewport.RenderViewportBase = viewport.RenderViewportBase$();
  dart.addTypeTests(viewport.RenderViewportBase, _is_RenderViewportBase_default);
  var _minScrollExtent = dart.privateName(viewport, "_minScrollExtent");
  var _maxScrollExtent = dart.privateName(viewport, "_maxScrollExtent");
  var _hasVisualOverflow = dart.privateName(viewport, "_hasVisualOverflow");
  var _anchor = dart.privateName(viewport, "_anchor");
  var _center = dart.privateName(viewport, "_center");
  var _attemptLayout = dart.privateName(viewport, "_attemptLayout");
  var SemanticsTag_name = dart.privateName(semantics, "SemanticsTag.name");
  var C18;
  var C19;
  viewport.RenderViewport = class RenderViewport extends viewport.RenderViewportBase$(dart.legacy(sliver$.SliverPhysicalContainerParentData)) {
    setupParentData(child) {
      RenderObjectL().as(child);
      if (!SliverPhysicalContainerParentDataL().is(child.parentData)) child.parentData = new sliver$.SliverPhysicalContainerParentData.new();
    }
    get anchor() {
      return this[_anchor];
    }
    set anchor(value) {
      if (!(value != null)) dart.assertFailed(null, L3, 1224, 12, "value != null");
      if (!(dart.notNull(value) >= 0.0 && dart.notNull(value) <= 1.0)) dart.assertFailed(null, L3, 1225, 12, "value >= 0.0 && value <= 1.0");
      if (value == this[_anchor]) return;
      this[_anchor] = value;
      this.markNeedsLayout();
    }
    get center() {
      return this[_center];
    }
    set center(value) {
      if (dart.equals(value, this[_center])) return;
      this[_center] = value;
      this.markNeedsLayout();
    }
    get sizedByParent() {
      return true;
    }
    performResize() {
      if (!dart.test(dart.fn(() => {
        if (!dart.test(this.constraints.hasBoundedHeight) || !dart.test(this.constraints.hasBoundedWidth)) {
          switch (this.axis) {
            case C8 || CT.C8:
            {
              if (!dart.test(this.constraints.hasBoundedHeight)) {
                dart.throw(new assertions.FlutterError.fromParts(JSArrayOfDiagnosticsNodeL().of([new assertions.ErrorSummary.new("Vertical viewport was given unbounded height."), new assertions.ErrorDescription.new("Viewports expand in the scrolling direction to fill their container. " + "In this case, a vertical viewport was given an unlimited amount of " + "vertical space in which to expand. This situation typically happens " + "when a scrollable widget is nested inside another scrollable widget."), new assertions.ErrorHint.new("If this widget is always nested in a scrollable widget there " + "is no need to use a viewport because there will always be enough " + "vertical space for the children. In this case, consider using a " + "Column instead. Otherwise, consider using the \"shrinkWrap\" property " + "(or a ShrinkWrappingViewport) to size the height of the viewport " + "to the sum of the heights of its children.")])));
              }
              if (!dart.test(this.constraints.hasBoundedWidth)) {
                dart.throw(assertions.FlutterError.new("Vertical viewport was given unbounded width.\n" + "Viewports expand in the cross axis to fill their container and " + "constrain their children to match their extent in the cross axis. " + "In this case, a vertical viewport was given an unlimited amount of " + "horizontal space in which to expand."));
              }
              break;
            }
            case C7 || CT.C7:
            {
              if (!dart.test(this.constraints.hasBoundedWidth)) {
                dart.throw(new assertions.FlutterError.fromParts(JSArrayOfDiagnosticsNodeL().of([new assertions.ErrorSummary.new("Horizontal viewport was given unbounded width."), new assertions.ErrorDescription.new("Viewports expand in the scrolling direction to fill their container. " + "In this case, a horizontal viewport was given an unlimited amount of " + "horizontal space in which to expand. This situation typically happens " + "when a scrollable widget is nested inside another scrollable widget."), new assertions.ErrorHint.new("If this widget is always nested in a scrollable widget there " + "is no need to use a viewport because there will always be enough " + "horizontal space for the children. In this case, consider using a " + "Row instead. Otherwise, consider using the \"shrinkWrap\" property " + "(or a ShrinkWrappingViewport) to size the width of the viewport " + "to the sum of the widths of its children.")])));
              }
              if (!dart.test(this.constraints.hasBoundedHeight)) {
                dart.throw(assertions.FlutterError.new("Horizontal viewport was given unbounded height.\n" + "Viewports expand in the cross axis to fill their container and " + "constrain their children to match their extent in the cross axis. " + "In this case, a horizontal viewport was given an unlimited amount of " + "vertical space in which to expand."));
              }
              break;
            }
          }
        }
        return true;
      }, VoidToboolL())())) dart.assertFailed(null, L3, 1256, 12, "() {\r\n      if (!constraints.hasBoundedHeight || !constraints.hasBoundedWidth) {\r\n        switch (axis) {\r\n          case Axis.vertical:\r\n            if (!constraints.hasBoundedHeight) {\r\n              throw FlutterError.fromParts(<DiagnosticsNode>[\r\n                ErrorSummary('Vertical viewport was given unbounded height.'),\r\n                ErrorDescription(\r\n                  'Viewports expand in the scrolling direction to fill their container. '\r\n                  'In this case, a vertical viewport was given an unlimited amount of '\r\n                  'vertical space in which to expand. This situation typically happens '\r\n                  'when a scrollable widget is nested inside another scrollable widget.'\r\n                ),\r\n                ErrorHint(\r\n                  'If this widget is always nested in a scrollable widget there '\r\n                  'is no need to use a viewport because there will always be enough '\r\n                  'vertical space for the children. In this case, consider using a '\r\n                  'Column instead. Otherwise, consider using the \"shrinkWrap\" property '\r\n                  '(or a ShrinkWrappingViewport) to size the height of the viewport '\r\n                  'to the sum of the heights of its children.'\r\n                )\r\n              ]);\r\n            }\r\n            if (!constraints.hasBoundedWidth) {\r\n              throw FlutterError(\r\n                'Vertical viewport was given unbounded width.\\n'\r\n                'Viewports expand in the cross axis to fill their container and '\r\n                'constrain their children to match their extent in the cross axis. '\r\n                'In this case, a vertical viewport was given an unlimited amount of '\r\n                'horizontal space in which to expand.'\r\n              );\r\n            }\r\n            break;\r\n          case Axis.horizontal:\r\n            if (!constraints.hasBoundedWidth) {\r\n              throw FlutterError.fromParts(<DiagnosticsNode>[\r\n                ErrorSummary('Horizontal viewport was given unbounded width.'),\r\n                ErrorDescription(\r\n                  'Viewports expand in the scrolling direction to fill their container. '\r\n                  'In this case, a horizontal viewport was given an unlimited amount of '\r\n                  'horizontal space in which to expand. This situation typically happens '\r\n                  'when a scrollable widget is nested inside another scrollable widget.'\r\n                ),\r\n                ErrorHint(\r\n                  'If this widget is always nested in a scrollable widget there '\r\n                  'is no need to use a viewport because there will always be enough '\r\n                  'horizontal space for the children. In this case, consider using a '\r\n                  'Row instead. Otherwise, consider using the \"shrinkWrap\" property '\r\n                  '(or a ShrinkWrappingViewport) to size the width of the viewport '\r\n                  'to the sum of the widths of its children.'\r\n                )\r\n              ]);\r\n            }\r\n            if (!constraints.hasBoundedHeight) {\r\n              throw FlutterError(\r\n                'Horizontal viewport was given unbounded height.\\n'\r\n                'Viewports expand in the cross axis to fill their container and '\r\n                'constrain their children to match their extent in the cross axis. '\r\n                'In this case, a horizontal viewport was given an unlimited amount of '\r\n                'vertical space in which to expand.'\r\n              );\r\n            }\r\n            break;\r\n        }\r\n      }\r\n      return true;\r\n    }()");
      this.size = this.constraints.biggest;
      switch (this.axis) {
        case C8 || CT.C8:
        {
          this.offset.applyViewportDimension(this.size.height);
          break;
        }
        case C7 || CT.C7:
        {
          this.offset.applyViewportDimension(this.size.width);
          break;
        }
      }
    }
    performLayout() {
      if (this.center == null) {
        if (!(this.firstChild == null)) dart.assertFailed(null, L3, 1346, 14, "firstChild == null");
        this[_minScrollExtent] = 0.0;
        this[_maxScrollExtent] = 0.0;
        this[_hasVisualOverflow] = false;
        this.offset.applyContentDimensions(0.0, 0.0);
        return;
      }
      if (!dart.equals(this.center.parent, this)) dart.assertFailed(null, L3, 1353, 12, "center.parent == this");
      let mainAxisExtent = null;
      let crossAxisExtent = null;
      switch (this.axis) {
        case C8 || CT.C8:
        {
          mainAxisExtent = this.size.height;
          crossAxisExtent = this.size.width;
          break;
        }
        case C7 || CT.C7:
        {
          mainAxisExtent = this.size.width;
          crossAxisExtent = this.size.height;
          break;
        }
      }
      let centerOffsetAdjustment = this.center.centerOffsetAdjustment;
      let correction = null;
      let count = 0;
      do {
        if (!(this.offset.pixels != null)) dart.assertFailed(null, L3, 1373, 14, "offset.pixels != null");
        correction = this[_attemptLayout](mainAxisExtent, crossAxisExtent, dart.notNull(this.offset.pixels) + dart.notNull(centerOffsetAdjustment));
        if (correction !== 0.0) {
          this.offset.correctBy(correction);
        } else {
          if (dart.test(this.offset.applyContentDimensions(math.min(doubleL(), 0.0, dart.notNull(this[_minScrollExtent]) + dart.notNull(mainAxisExtent) * dart.notNull(this.anchor)), math.max(doubleL(), 0.0, dart.notNull(this[_maxScrollExtent]) - dart.notNull(mainAxisExtent) * (1.0 - dart.notNull(this.anchor)))))) break;
        }
        count = count + 1;
      } while (count < 10);
      if (!dart.test(dart.fn(() => {
        if (count >= 10) {
          if (!(count !== 1)) dart.assertFailed(null, L3, 1388, 16, "count != 1");
          dart.throw(assertions.FlutterError.new("A RenderViewport exceeded its maximum number of layout cycles.\n" + "RenderViewport render objects, during layout, can retry if either their " + "slivers or their ViewportOffset decide that the offset should be corrected " + "to take into account information collected during that layout.\n" + "In the case of this RenderViewport object, however, this happened " + dart.str(count) + " " + "times and still there was no consensus on the scroll offset. This usually " + "indicates a bug. Specifically, it means that one of the following three " + "problems is being experienced by the RenderViewport object:\n" + " * One of the RenderSliver children or the ViewportOffset have a bug such" + " that they always think that they need to correct the offset regardless.\n" + " * Some combination of the RenderSliver children and the ViewportOffset" + " have a bad interaction such that one applies a correction then another" + " applies a reverse correction, leading to an infinite loop of corrections.\n" + " * There is a pathological case that would eventually resolve, but it is" + " so complicated that it cannot be resolved in any reasonable number of" + " layout passes."));
        }
        return true;
      }, VoidToboolL())())) dart.assertFailed(null, L3, 1386, 12, "() {\r\n      if (count >= _maxLayoutCycles) {\r\n        assert(count != 1);\r\n        throw FlutterError(\r\n          'A RenderViewport exceeded its maximum number of layout cycles.\\n'\r\n          'RenderViewport render objects, during layout, can retry if either their '\r\n          'slivers or their ViewportOffset decide that the offset should be corrected '\r\n          'to take into account information collected during that layout.\\n'\r\n          'In the case of this RenderViewport object, however, this happened $count '\r\n          'times and still there was no consensus on the scroll offset. This usually '\r\n          'indicates a bug. Specifically, it means that one of the following three '\r\n          'problems is being experienced by the RenderViewport object:\\n'\r\n          ' * One of the RenderSliver children or the ViewportOffset have a bug such'\r\n          ' that they always think that they need to correct the offset regardless.\\n'\r\n          ' * Some combination of the RenderSliver children and the ViewportOffset'\r\n          ' have a bad interaction such that one applies a correction then another'\r\n          ' applies a reverse correction, leading to an infinite loop of corrections.\\n'\r\n          ' * There is a pathological case that would eventually resolve, but it is'\r\n          ' so complicated that it cannot be resolved in any reasonable number of'\r\n          ' layout passes.'\r\n        );\r\n      }\r\n      return true;\r\n    }()");
    }
    [_attemptLayout](mainAxisExtent, crossAxisExtent, correctedOffset) {
      if (!!mainAxisExtent[$isNaN]) dart.assertFailed(null, L3, 1413, 12, "!mainAxisExtent.isNaN");
      if (!(dart.notNull(mainAxisExtent) >= 0.0)) dart.assertFailed(null, L3, 1414, 12, "mainAxisExtent >= 0.0");
      if (!crossAxisExtent[$isFinite]) dart.assertFailed(null, L3, 1415, 12, "crossAxisExtent.isFinite");
      if (!(dart.notNull(crossAxisExtent) >= 0.0)) dart.assertFailed(null, L3, 1416, 12, "crossAxisExtent >= 0.0");
      if (!correctedOffset[$isFinite]) dart.assertFailed(null, L3, 1417, 12, "correctedOffset.isFinite");
      this[_minScrollExtent] = 0.0;
      this[_maxScrollExtent] = 0.0;
      this[_hasVisualOverflow] = false;
      let centerOffset = dart.notNull(mainAxisExtent) * dart.notNull(this.anchor) - dart.notNull(correctedOffset);
      let reverseDirectionRemainingPaintExtent = centerOffset[$clamp](0.0, mainAxisExtent);
      let forwardDirectionRemainingPaintExtent = (dart.notNull(mainAxisExtent) - centerOffset)[$clamp](0.0, mainAxisExtent);
      switch (this.cacheExtentStyle) {
        case C11 || CT.C11:
        {
          this[_calculatedCacheExtent] = this.cacheExtent;
          break;
        }
        case C12 || CT.C12:
        {
          this[_calculatedCacheExtent] = dart.notNull(mainAxisExtent) * dart.notNull(this.cacheExtent);
          break;
        }
      }
      let fullCacheExtent = dart.notNull(mainAxisExtent) + 2 * dart.notNull(this[_calculatedCacheExtent]);
      let centerCacheOffset = centerOffset + dart.notNull(this[_calculatedCacheExtent]);
      let reverseDirectionRemainingCacheExtent = centerCacheOffset[$clamp](0.0, fullCacheExtent);
      let forwardDirectionRemainingCacheExtent = (fullCacheExtent - centerCacheOffset)[$clamp](0.0, fullCacheExtent);
      let leadingNegativeChild = this.childBefore(this.center);
      if (leadingNegativeChild != null) {
        let result = this.layoutChildSequence({child: leadingNegativeChild, scrollOffset: math.max(doubleL(), mainAxisExtent, centerOffset) - dart.notNull(mainAxisExtent), overlap: 0.0, layoutOffset: forwardDirectionRemainingPaintExtent, remainingPaintExtent: reverseDirectionRemainingPaintExtent, mainAxisExtent: mainAxisExtent, crossAxisExtent: crossAxisExtent, growthDirection: sliver$.GrowthDirection.reverse, advance: dart.bind(this, 'childBefore'), remainingCacheExtent: reverseDirectionRemainingCacheExtent, cacheOrigin: (dart.notNull(mainAxisExtent) - centerOffset)[$clamp](-dart.notNull(this[_calculatedCacheExtent]), 0.0)});
        if (result !== 0.0) return -dart.notNull(result);
      }
      return this.layoutChildSequence({child: this.center, scrollOffset: math.max(doubleL(), 0.0, -centerOffset), overlap: leadingNegativeChild == null ? math.min(doubleL(), 0.0, -centerOffset) : 0.0, layoutOffset: centerOffset >= dart.notNull(mainAxisExtent) ? centerOffset : reverseDirectionRemainingPaintExtent, remainingPaintExtent: forwardDirectionRemainingPaintExtent, mainAxisExtent: mainAxisExtent, crossAxisExtent: crossAxisExtent, growthDirection: sliver$.GrowthDirection.forward, advance: dart.bind(this, 'childAfter'), remainingCacheExtent: forwardDirectionRemainingCacheExtent, cacheOrigin: centerOffset[$clamp](-dart.notNull(this[_calculatedCacheExtent]), 0.0)});
    }
    get hasVisualOverflow() {
      return this[_hasVisualOverflow];
    }
    updateOutOfBandData(growthDirection, childLayoutGeometry) {
      switch (growthDirection) {
        case C0 || CT.C0:
        {
          this[_maxScrollExtent] = dart.notNull(this[_maxScrollExtent]) + dart.notNull(childLayoutGeometry.scrollExtent);
          break;
        }
        case C1 || CT.C1:
        {
          this[_minScrollExtent] = dart.notNull(this[_minScrollExtent]) - dart.notNull(childLayoutGeometry.scrollExtent);
          break;
        }
      }
      if (dart.test(childLayoutGeometry.hasVisualOverflow)) this[_hasVisualOverflow] = true;
    }
    updateChildLayoutOffset(child, layoutOffset, growthDirection) {
      let childParentData = SliverPhysicalParentDataL().as(child.parentData);
      childParentData.paintOffset = this.computeAbsolutePaintOffset(child, layoutOffset, growthDirection);
    }
    paintOffsetOf(child) {
      let childParentData = SliverPhysicalParentDataL().as(child.parentData);
      return childParentData.paintOffset;
    }
    scrollOffsetOf(child, scrollOffsetWithinChild) {
      if (!dart.equals(child.parent, this)) dart.assertFailed(null, L3, 1511, 12, "child.parent == this");
      let growthDirection = child.constraints.growthDirection;
      if (!(growthDirection != null)) dart.assertFailed(null, L3, 1513, 12, "growthDirection != null");
      switch (growthDirection) {
        case C0 || CT.C0:
        {
          let scrollOffsetToChild = 0.0;
          let current = this.center;
          while (!dart.equals(current, child)) {
            scrollOffsetToChild = scrollOffsetToChild + dart.notNull(current.geometry.scrollExtent);
            current = this.childAfter(current);
          }
          return scrollOffsetToChild + dart.notNull(scrollOffsetWithinChild);
        }
        case C1 || CT.C1:
        {
          let scrollOffsetToChild = 0.0;
          let current = this.childBefore(this.center);
          while (!dart.equals(current, child)) {
            scrollOffsetToChild = scrollOffsetToChild - dart.notNull(current.geometry.scrollExtent);
            current = this.childBefore(current);
          }
          return scrollOffsetToChild - dart.notNull(scrollOffsetWithinChild);
        }
      }
      return null;
    }
    maxScrollObstructionExtentBefore(child) {
      if (!dart.equals(child.parent, this)) dart.assertFailed(null, L3, 1537, 12, "child.parent == this");
      let growthDirection = child.constraints.growthDirection;
      if (!(growthDirection != null)) dart.assertFailed(null, L3, 1539, 12, "growthDirection != null");
      switch (growthDirection) {
        case C0 || CT.C0:
        {
          let pinnedExtent = 0.0;
          let current = this.center;
          while (!dart.equals(current, child)) {
            pinnedExtent = pinnedExtent + dart.notNull(current.geometry.maxScrollObstructionExtent);
            current = this.childAfter(current);
          }
          return pinnedExtent;
        }
        case C1 || CT.C1:
        {
          let pinnedExtent = 0.0;
          let current = this.childBefore(this.center);
          while (!dart.equals(current, child)) {
            pinnedExtent = pinnedExtent + dart.notNull(current.geometry.maxScrollObstructionExtent);
            current = this.childBefore(current);
          }
          return pinnedExtent;
        }
      }
      return null;
    }
    applyPaintTransform(child, transform) {
      RenderObjectL().as(child);
      if (!(child != null)) dart.assertFailed(null, L3, 1563, 12, "child != null");
      let childParentData = SliverPhysicalParentDataL().as(child.parentData);
      childParentData.applyPaintTransform(transform);
    }
    computeChildMainAxisPosition(child, parentMainAxisPosition) {
      if (!(child != null)) dart.assertFailed(null, L3, 1570, 12, "child != null");
      if (!(child.constraints != null)) dart.assertFailed(null, L3, 1571, 12, "child.constraints != null");
      let childParentData = SliverPhysicalParentDataL().as(child.parentData);
      switch (sliver$.applyGrowthDirectionToAxisDirection(child.constraints.axisDirection, child.constraints.growthDirection)) {
        case C3 || CT.C3:
        {
          return dart.notNull(parentMainAxisPosition) - dart.notNull(childParentData.paintOffset.dy);
        }
        case C4 || CT.C4:
        {
          return dart.notNull(parentMainAxisPosition) - dart.notNull(childParentData.paintOffset.dx);
        }
        case C5 || CT.C5:
        {
          return dart.notNull(child.geometry.paintExtent) - (dart.notNull(parentMainAxisPosition) - dart.notNull(childParentData.paintOffset.dy));
        }
        case C6 || CT.C6:
        {
          return dart.notNull(child.geometry.paintExtent) - (dart.notNull(parentMainAxisPosition) - dart.notNull(childParentData.paintOffset.dx));
        }
      }
      return 0.0;
    }
    get indexOfFirstChild() {
      if (!(this.center != null)) dart.assertFailed(null, L3, 1588, 12, "center != null");
      if (!dart.equals(this.center.parent, this)) dart.assertFailed(null, L3, 1589, 12, "center.parent == this");
      if (!(this.firstChild != null)) dart.assertFailed(null, L3, 1590, 12, "firstChild != null");
      let count = 0;
      let child = this.center;
      while (!dart.equals(child, this.firstChild)) {
        count = count - 1;
        child = this.childBefore(child);
      }
      return count;
    }
    labelForChild(index) {
      if (index === 0) return "center child";
      return "child " + dart.str(index);
    }
    get childrenInPaintOrder() {
      return new (SyncIterableOfRenderSliverL()).new((function* childrenInPaintOrder() {
        if (this.firstChild == null) return;
        let child = this.firstChild;
        while (!dart.equals(child, this.center)) {
          yield child;
          child = this.childAfter(child);
        }
        child = this.lastChild;
        while (true) {
          yield child;
          if (dart.equals(child, this.center)) return;
          child = this.childBefore(child);
        }
      }).bind(this));
    }
    get childrenInHitTestOrder() {
      return new (SyncIterableOfRenderSliverL()).new((function* childrenInHitTestOrder() {
        if (this.firstChild == null) return;
        let child = this.center;
        while (child != null) {
          yield child;
          child = this.childAfter(child);
        }
        child = this.childBefore(this.center);
        while (child != null) {
          yield child;
          child = this.childBefore(child);
        }
      }).bind(this));
    }
    debugFillProperties(properties) {
      super.debugFillProperties(properties);
      properties.add(new diagnostics.DoubleProperty.new("anchor", this.anchor));
    }
  };
  (viewport.RenderViewport.new = function(opts) {
    let axisDirection = opts && 'axisDirection' in opts ? opts.axisDirection : C3 || CT.C3;
    let crossAxisDirection = opts && 'crossAxisDirection' in opts ? opts.crossAxisDirection : null;
    let offset = opts && 'offset' in opts ? opts.offset : null;
    let anchor = opts && 'anchor' in opts ? opts.anchor : 0;
    let children = opts && 'children' in opts ? opts.children : null;
    let center = opts && 'center' in opts ? opts.center : null;
    let cacheExtent = opts && 'cacheExtent' in opts ? opts.cacheExtent : null;
    let cacheExtentStyle = opts && 'cacheExtentStyle' in opts ? opts.cacheExtentStyle : C11 || CT.C11;
    let clipBehavior = opts && 'clipBehavior' in opts ? opts.clipBehavior : C14 || CT.C14;
    this[_minScrollExtent] = null;
    this[_maxScrollExtent] = null;
    this[_hasVisualOverflow] = false;
    if (!(anchor != null)) dart.assertFailed(null, L3, 1159, 15, "anchor != null");
    if (!(dart.notNull(anchor) >= 0.0 && dart.notNull(anchor) <= 1.0)) dart.assertFailed(null, L3, 1160, 15, "anchor >= 0.0 && anchor <= 1.0");
    if (!(cacheExtentStyle != viewport.CacheExtentStyle.viewport || cacheExtent != null)) dart.assertFailed(null, L3, 1161, 15, "cacheExtentStyle != CacheExtentStyle.viewport || cacheExtent != null");
    if (!(clipBehavior != null)) dart.assertFailed(null, L3, 1162, 15, "clipBehavior != null");
    this[_anchor] = anchor;
    this[_center] = center;
    viewport.RenderViewport.__proto__.new.call(this, {axisDirection: axisDirection, crossAxisDirection: crossAxisDirection, offset: offset, cacheExtent: cacheExtent, cacheExtentStyle: cacheExtentStyle, clipBehavior: clipBehavior});
    this.addAll(children);
    if (center == null && this.firstChild != null) this[_center] = this.firstChild;
  }).prototype = viewport.RenderViewport.prototype;
  dart.addTypeTests(viewport.RenderViewport);
  dart.addTypeCaches(viewport.RenderViewport);
  dart.setMethodSignature(viewport.RenderViewport, () => ({
    __proto__: dart.getMethods(viewport.RenderViewport.__proto__),
    [_attemptLayout]: dart.fnType(dart.legacy(core.double), [dart.legacy(core.double), dart.legacy(core.double), dart.legacy(core.double)]),
    updateOutOfBandData: dart.fnType(dart.void, [dart.legacy(sliver$.GrowthDirection), dart.legacy(sliver$.SliverGeometry)]),
    updateChildLayoutOffset: dart.fnType(dart.void, [dart.legacy(sliver$.RenderSliver), dart.legacy(core.double), dart.legacy(sliver$.GrowthDirection)]),
    paintOffsetOf: dart.fnType(dart.legacy(ui.Offset), [dart.legacy(sliver$.RenderSliver)]),
    scrollOffsetOf: dart.fnType(dart.legacy(core.double), [dart.legacy(sliver$.RenderSliver), dart.legacy(core.double)]),
    maxScrollObstructionExtentBefore: dart.fnType(dart.legacy(core.double), [dart.legacy(sliver$.RenderSliver)]),
    computeChildMainAxisPosition: dart.fnType(dart.legacy(core.double), [dart.legacy(sliver$.RenderSliver), dart.legacy(core.double)]),
    labelForChild: dart.fnType(dart.legacy(core.String), [dart.legacy(core.int)])
  }));
  dart.setGetterSignature(viewport.RenderViewport, () => ({
    __proto__: dart.getGetters(viewport.RenderViewport.__proto__),
    anchor: dart.legacy(core.double),
    center: dart.legacy(sliver$.RenderSliver),
    hasVisualOverflow: dart.legacy(core.bool),
    indexOfFirstChild: dart.legacy(core.int),
    childrenInPaintOrder: dart.legacy(core.Iterable$(dart.legacy(sliver$.RenderSliver))),
    childrenInHitTestOrder: dart.legacy(core.Iterable$(dart.legacy(sliver$.RenderSliver)))
  }));
  dart.setSetterSignature(viewport.RenderViewport, () => ({
    __proto__: dart.getSetters(viewport.RenderViewport.__proto__),
    anchor: dart.legacy(core.double),
    center: dart.legacy(sliver$.RenderSliver)
  }));
  dart.setLibraryUri(viewport.RenderViewport, L2);
  dart.setFieldSignature(viewport.RenderViewport, () => ({
    __proto__: dart.getFields(viewport.RenderViewport.__proto__),
    [_anchor]: dart.fieldType(dart.legacy(core.double)),
    [_center]: dart.fieldType(dart.legacy(sliver$.RenderSliver)),
    [_minScrollExtent]: dart.fieldType(dart.legacy(core.double)),
    [_maxScrollExtent]: dart.fieldType(dart.legacy(core.double)),
    [_hasVisualOverflow]: dart.fieldType(dart.legacy(core.bool))
  }));
  dart.defineLazy(viewport.RenderViewport, {
    /*viewport.RenderViewport.useTwoPaneSemantics*/get useTwoPaneSemantics() {
      return C18 || CT.C18;
    },
    /*viewport.RenderViewport.excludeFromScrolling*/get excludeFromScrolling() {
      return C19 || CT.C19;
    },
    /*viewport.RenderViewport._maxLayoutCycles*/get _maxLayoutCycles() {
      return 10;
    }
  }, true);
  var _shrinkWrapExtent = dart.privateName(viewport, "_shrinkWrapExtent");
  viewport.RenderShrinkWrappingViewport = class RenderShrinkWrappingViewport extends viewport.RenderViewportBase$(dart.legacy(sliver$.SliverLogicalContainerParentData)) {
    setupParentData(child) {
      RenderObjectL().as(child);
      if (!SliverLogicalContainerParentDataL().is(child.parentData)) child.parentData = new sliver$.SliverLogicalContainerParentData.new();
    }
    debugThrowIfNotCheckingIntrinsics() {
      if (!dart.test(dart.fn(() => {
        if (!dart.test(object.RenderObject.debugCheckingIntrinsics)) {
          dart.throw(new assertions.FlutterError.fromParts(JSArrayOfDiagnosticsNodeL().of([new assertions.ErrorSummary.new(dart.str(this.runtimeType) + " does not support returning intrinsic dimensions."), new assertions.ErrorDescription.new("Calculating the intrinsic dimensions would require instantiating every child of " + "the viewport, which defeats the point of viewports being lazy."), new assertions.ErrorHint.new("If you are merely trying to shrink-wrap the viewport in the main axis direction, " + "you should be able to achieve that effect by just giving the viewport loose " + "constraints, without needing to measure its intrinsic dimensions.")])));
        }
        return true;
      }, VoidToboolL())())) dart.assertFailed(null, L3, 1702, 12, "() {\r\n      if (!RenderObject.debugCheckingIntrinsics) {\r\n        throw FlutterError.fromParts(<DiagnosticsNode>[\r\n          ErrorSummary('$runtimeType does not support returning intrinsic dimensions.'),\r\n          ErrorDescription(\r\n           'Calculating the intrinsic dimensions would require instantiating every child of '\r\n           'the viewport, which defeats the point of viewports being lazy.'\r\n          ),\r\n          ErrorHint(\r\n            'If you are merely trying to shrink-wrap the viewport in the main axis direction, '\r\n            'you should be able to achieve that effect by just giving the viewport loose '\r\n            'constraints, without needing to measure its intrinsic dimensions.'\r\n          )\r\n        ]);\r\n      }\r\n      return true;\r\n    }()");
      return true;
    }
    performLayout() {
      let constraints = this.constraints;
      if (this.firstChild == null) {
        switch (this.axis) {
          case C8 || CT.C8:
          {
            if (!dart.test(constraints.hasBoundedWidth)) dart.assertFailed(null, L3, 1733, 18, "constraints.hasBoundedWidth");
            this.size = new ui.Size.new(constraints.maxWidth, constraints.minHeight);
            break;
          }
          case C7 || CT.C7:
          {
            if (!dart.test(constraints.hasBoundedHeight)) dart.assertFailed(null, L3, 1737, 18, "constraints.hasBoundedHeight");
            this.size = new ui.Size.new(constraints.minWidth, constraints.maxHeight);
            break;
          }
        }
        this.offset.applyViewportDimension(0.0);
        this[_maxScrollExtent] = 0.0;
        this[_shrinkWrapExtent] = 0.0;
        this[_hasVisualOverflow] = false;
        this.offset.applyContentDimensions(0.0, 0.0);
        return;
      }
      let mainAxisExtent = null;
      let crossAxisExtent = null;
      switch (this.axis) {
        case C8 || CT.C8:
        {
          if (!dart.test(constraints.hasBoundedWidth)) dart.assertFailed(null, L3, 1753, 16, "constraints.hasBoundedWidth");
          mainAxisExtent = constraints.maxHeight;
          crossAxisExtent = constraints.maxWidth;
          break;
        }
        case C7 || CT.C7:
        {
          if (!dart.test(constraints.hasBoundedHeight)) dart.assertFailed(null, L3, 1758, 16, "constraints.hasBoundedHeight");
          mainAxisExtent = constraints.maxWidth;
          crossAxisExtent = constraints.maxHeight;
          break;
        }
      }
      let correction = null;
      let effectiveExtent = null;
      do {
        if (!(this.offset.pixels != null)) dart.assertFailed(null, L3, 1767, 14, "offset.pixels != null");
        correction = this[_attemptLayout](mainAxisExtent, crossAxisExtent, this.offset.pixels);
        if (correction !== 0.0) {
          this.offset.correctBy(correction);
        } else {
          switch (this.axis) {
            case C8 || CT.C8:
            {
              effectiveExtent = constraints.constrainHeight(this[_shrinkWrapExtent]);
              break;
            }
            case C7 || CT.C7:
            {
              effectiveExtent = constraints.constrainWidth(this[_shrinkWrapExtent]);
              break;
            }
          }
          let didAcceptViewportDimension = this.offset.applyViewportDimension(effectiveExtent);
          let didAcceptContentDimension = this.offset.applyContentDimensions(0.0, math.max(doubleL(), 0.0, dart.notNull(this[_maxScrollExtent]) - dart.notNull(effectiveExtent)));
          if (dart.test(didAcceptViewportDimension) && dart.test(didAcceptContentDimension)) break;
        }
      } while (true);
      switch (this.axis) {
        case C8 || CT.C8:
        {
          this.size = constraints.constrainDimensions(crossAxisExtent, effectiveExtent);
          break;
        }
        case C7 || CT.C7:
        {
          this.size = constraints.constrainDimensions(effectiveExtent, crossAxisExtent);
          break;
        }
      }
    }
    [_attemptLayout](mainAxisExtent, crossAxisExtent, correctedOffset) {
      if (!!mainAxisExtent[$isNaN]) dart.assertFailed(null, L3, 1802, 12, "!mainAxisExtent.isNaN");
      if (!(dart.notNull(mainAxisExtent) >= 0.0)) dart.assertFailed(null, L3, 1803, 12, "mainAxisExtent >= 0.0");
      if (!crossAxisExtent[$isFinite]) dart.assertFailed(null, L3, 1804, 12, "crossAxisExtent.isFinite");
      if (!(dart.notNull(crossAxisExtent) >= 0.0)) dart.assertFailed(null, L3, 1805, 12, "crossAxisExtent >= 0.0");
      if (!correctedOffset[$isFinite]) dart.assertFailed(null, L3, 1806, 12, "correctedOffset.isFinite");
      this[_maxScrollExtent] = 0.0;
      this[_shrinkWrapExtent] = 0.0;
      this[_hasVisualOverflow] = false;
      return this.layoutChildSequence({child: this.firstChild, scrollOffset: math.max(doubleL(), 0.0, correctedOffset), overlap: math.min(doubleL(), 0.0, correctedOffset), layoutOffset: 0.0, remainingPaintExtent: mainAxisExtent, mainAxisExtent: mainAxisExtent, crossAxisExtent: crossAxisExtent, growthDirection: sliver$.GrowthDirection.forward, advance: dart.bind(this, 'childAfter'), remainingCacheExtent: dart.notNull(mainAxisExtent) + 2 * dart.notNull(this.cacheExtent), cacheOrigin: -dart.notNull(this.cacheExtent)});
    }
    get hasVisualOverflow() {
      return this[_hasVisualOverflow];
    }
    updateOutOfBandData(growthDirection, childLayoutGeometry) {
      if (!(growthDirection == sliver$.GrowthDirection.forward)) dart.assertFailed(null, L3, 1830, 12, "growthDirection == GrowthDirection.forward");
      this[_maxScrollExtent] = dart.notNull(this[_maxScrollExtent]) + dart.notNull(childLayoutGeometry.scrollExtent);
      if (dart.test(childLayoutGeometry.hasVisualOverflow)) this[_hasVisualOverflow] = true;
      this[_shrinkWrapExtent] = dart.notNull(this[_shrinkWrapExtent]) + dart.notNull(childLayoutGeometry.maxPaintExtent);
    }
    updateChildLayoutOffset(child, layoutOffset, growthDirection) {
      if (!(growthDirection == sliver$.GrowthDirection.forward)) dart.assertFailed(null, L3, 1839, 12, "growthDirection == GrowthDirection.forward");
      let childParentData = SliverLogicalParentDataL().as(child.parentData);
      childParentData.layoutOffset = layoutOffset;
    }
    paintOffsetOf(child) {
      let childParentData = SliverLogicalParentDataL().as(child.parentData);
      return this.computeAbsolutePaintOffset(child, childParentData.layoutOffset, sliver$.GrowthDirection.forward);
    }
    scrollOffsetOf(child, scrollOffsetWithinChild) {
      if (!dart.equals(child.parent, this)) dart.assertFailed(null, L3, 1852, 12, "child.parent == this");
      if (!(child.constraints.growthDirection == sliver$.GrowthDirection.forward)) dart.assertFailed(null, L3, 1853, 12, "child.constraints.growthDirection == GrowthDirection.forward");
      let scrollOffsetToChild = 0.0;
      let current = this.firstChild;
      while (!dart.equals(current, child)) {
        scrollOffsetToChild = scrollOffsetToChild + dart.notNull(current.geometry.scrollExtent);
        current = this.childAfter(current);
      }
      return scrollOffsetToChild + dart.notNull(scrollOffsetWithinChild);
    }
    maxScrollObstructionExtentBefore(child) {
      if (!dart.equals(child.parent, this)) dart.assertFailed(null, L3, 1865, 12, "child.parent == this");
      if (!(child.constraints.growthDirection == sliver$.GrowthDirection.forward)) dart.assertFailed(null, L3, 1866, 12, "child.constraints.growthDirection == GrowthDirection.forward");
      let pinnedExtent = 0.0;
      let current = this.firstChild;
      while (!dart.equals(current, child)) {
        pinnedExtent = pinnedExtent + dart.notNull(current.geometry.maxScrollObstructionExtent);
        current = this.childAfter(current);
      }
      return pinnedExtent;
    }
    applyPaintTransform(child, transform) {
      RenderObjectL().as(child);
      if (!(child != null)) dart.assertFailed(null, L3, 1878, 12, "child != null");
      let offset = this.paintOffsetOf(RenderSliverL().as(child));
      transform.translate(offset.dx, offset.dy);
    }
    computeChildMainAxisPosition(child, parentMainAxisPosition) {
      if (!(child != null)) dart.assertFailed(null, L3, 1885, 12, "child != null");
      if (!(child.constraints != null)) dart.assertFailed(null, L3, 1886, 12, "child.constraints != null");
      if (!dart.test(this.hasSize)) dart.assertFailed(null, L3, 1887, 12, "hasSize");
      let childParentData = SliverLogicalParentDataL().as(child.parentData);
      switch (sliver$.applyGrowthDirectionToAxisDirection(child.constraints.axisDirection, child.constraints.growthDirection)) {
        case C3 || CT.C3:
        case C4 || CT.C4:
        {
          return dart.notNull(parentMainAxisPosition) - dart.notNull(childParentData.layoutOffset);
        }
        case C5 || CT.C5:
        {
          return dart.notNull(this.size.height) - dart.notNull(parentMainAxisPosition) - dart.notNull(childParentData.layoutOffset);
        }
        case C6 || CT.C6:
        {
          return dart.notNull(this.size.width) - dart.notNull(parentMainAxisPosition) - dart.notNull(childParentData.layoutOffset);
        }
      }
      return 0.0;
    }
    get indexOfFirstChild() {
      return 0;
    }
    labelForChild(index) {
      return "child " + dart.str(index);
    }
    get childrenInPaintOrder() {
      return new (SyncIterableOfRenderSliverL()).new((function* childrenInPaintOrder() {
        let child = this.firstChild;
        while (child != null) {
          yield child;
          child = this.childAfter(child);
        }
      }).bind(this));
    }
    get childrenInHitTestOrder() {
      return new (SyncIterableOfRenderSliverL()).new((function* childrenInHitTestOrder() {
        let child = this.lastChild;
        while (child != null) {
          yield child;
          child = this.childBefore(child);
        }
      }).bind(this));
    }
  };
  (viewport.RenderShrinkWrappingViewport.new = function(opts) {
    let axisDirection = opts && 'axisDirection' in opts ? opts.axisDirection : C3 || CT.C3;
    let crossAxisDirection = opts && 'crossAxisDirection' in opts ? opts.crossAxisDirection : null;
    let offset = opts && 'offset' in opts ? opts.offset : null;
    let clipBehavior = opts && 'clipBehavior' in opts ? opts.clipBehavior : C14 || CT.C14;
    let children = opts && 'children' in opts ? opts.children : null;
    this[_maxScrollExtent] = null;
    this[_shrinkWrapExtent] = null;
    this[_hasVisualOverflow] = false;
    viewport.RenderShrinkWrappingViewport.__proto__.new.call(this, {axisDirection: axisDirection, crossAxisDirection: crossAxisDirection, offset: offset, clipBehavior: clipBehavior});
    this.addAll(children);
  }).prototype = viewport.RenderShrinkWrappingViewport.prototype;
  dart.addTypeTests(viewport.RenderShrinkWrappingViewport);
  dart.addTypeCaches(viewport.RenderShrinkWrappingViewport);
  dart.setMethodSignature(viewport.RenderShrinkWrappingViewport, () => ({
    __proto__: dart.getMethods(viewport.RenderShrinkWrappingViewport.__proto__),
    [_attemptLayout]: dart.fnType(dart.legacy(core.double), [dart.legacy(core.double), dart.legacy(core.double), dart.legacy(core.double)]),
    updateOutOfBandData: dart.fnType(dart.void, [dart.legacy(sliver$.GrowthDirection), dart.legacy(sliver$.SliverGeometry)]),
    updateChildLayoutOffset: dart.fnType(dart.void, [dart.legacy(sliver$.RenderSliver), dart.legacy(core.double), dart.legacy(sliver$.GrowthDirection)]),
    paintOffsetOf: dart.fnType(dart.legacy(ui.Offset), [dart.legacy(sliver$.RenderSliver)]),
    scrollOffsetOf: dart.fnType(dart.legacy(core.double), [dart.legacy(sliver$.RenderSliver), dart.legacy(core.double)]),
    maxScrollObstructionExtentBefore: dart.fnType(dart.legacy(core.double), [dart.legacy(sliver$.RenderSliver)]),
    computeChildMainAxisPosition: dart.fnType(dart.legacy(core.double), [dart.legacy(sliver$.RenderSliver), dart.legacy(core.double)]),
    labelForChild: dart.fnType(dart.legacy(core.String), [dart.legacy(core.int)])
  }));
  dart.setGetterSignature(viewport.RenderShrinkWrappingViewport, () => ({
    __proto__: dart.getGetters(viewport.RenderShrinkWrappingViewport.__proto__),
    hasVisualOverflow: dart.legacy(core.bool),
    indexOfFirstChild: dart.legacy(core.int),
    childrenInPaintOrder: dart.legacy(core.Iterable$(dart.legacy(sliver$.RenderSliver))),
    childrenInHitTestOrder: dart.legacy(core.Iterable$(dart.legacy(sliver$.RenderSliver)))
  }));
  dart.setLibraryUri(viewport.RenderShrinkWrappingViewport, L2);
  dart.setFieldSignature(viewport.RenderShrinkWrappingViewport, () => ({
    __proto__: dart.getFields(viewport.RenderShrinkWrappingViewport.__proto__),
    [_maxScrollExtent]: dart.fieldType(dart.legacy(core.double)),
    [_shrinkWrapExtent]: dart.fieldType(dart.legacy(core.double)),
    [_hasVisualOverflow]: dart.fieldType(dart.legacy(core.bool))
  }));
  dart.trackLibraries("packages/flutter/src/rendering/sliver.dart", {
    "package:flutter/src/rendering/sliver.dart": sliver$,
    "package:flutter/src/rendering/viewport.dart": viewport
  }, {
  }, '{"version":3,"sourceRoot":"","sources":["sliver.dart","viewport.dart"],"names":[],"mappings":"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","file":"../../../../../../packages/flutter/src/rendering/sliver.dart.lib.js"}');
  // Exports:
  return {
    src__rendering__sliver: sliver$,
    src__rendering__viewport: viewport
  };
}));

//# sourceMappingURL=sliver.dart.lib.js.map
